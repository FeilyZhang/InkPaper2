title: "C++自定义数据类型"
date: 2019-08-09 20:29:42 +0800
update: 2019-08-09 20:29:42 +0800
author: me
cover: "-/images/c++.jpg"
tags:
    - C++
preview: C++自定义数据类型包括数组、结构体、共用体、枚举。写C/C++不用指针是没有灵魂的！

---

## 一、数组

C++数组的定义必须指明数组长度，通用格式如下

```
typeName arrayName[arraySize];
```

一维数组与二维数组的示例如下：

```
#include <iostream>

int main() {
	int arr[5];
	int arr_length = sizeof arr / sizeof arr[0];
	for (int i = 0; i < arr_length; i++) {
		arr[i] = i * i;
	}
	int index = 0;
	int* pArr = arr;
	while (index != arr_length) {
		std::cout << *(pArr + index) << "\t";
		++index;
	}
	int arrt[5][4];
	int arr_row_len = sizeof arrt / sizeof arrt[0];
	int arr_col_len = sizeof arrt[0] / sizeof arrt[0][0];
	for (int i = 0; i < arr_row_len; i++) {
		for (int j = 0; j < arr_col_len; j++) {
			arrt[i][j] = i * j;
		}
	}
	std::cout << std::endl;
	int(*pArrt)[4];
	pArrt = arrt;
	int row_index = 0, col_index = 0;
	for (int i = 0; i < arr_row_len; i++) {
		for (int j = 0; j < arr_col_len; j++) {
			std::cout << *(*(pArrt + i) + j) << "\t";
		}
		std::cout << std::endl;
	}
	std::cin.get();
	return 0;
}
```

输出为

```
0       1       4       9       16
0       0       0       0
0       1       2       3
0       2       4       6
0       3       6       9
0       4       8       12
```

上述程序分别演示了一维数组和二维数组，并且数组的输入是采用常规的方式，数组的输出是采用指针的方式。

一维数组的指针使用符合上文中的两个等式，如下

```
arr[i] = *(ar + i);
&arr[i] = ar + i; 
```

**而二维数组的指针则相对麻烦一点，解释如下**

一维数组中声明指针的方式如下

```
int* pArr = arr;
```

此时指针pArr中存储的是数组的首元素的地址，通过指针对元素的访问是加上元素偏移实现的，而指针的长度则可以防止访问越界。二维数组的指针我们换个方式看一下

仍然是基于上述程序，我们尝试输出一下pArrt

```
std::cout << pArrt;    // 0034FC2C
```

是一个地址，这很容易理解，毕竟指针存的就是地址，那么`*pArrt`以及`*(pArrt + 1)`呢，按照常理，如果pArrt是地址，那么pArrt + 1就是pArrt指针指向内存区的下一个内存区的地址，对二者取值必然是两个连续地址空间的值了，但是真的是这样吗？

```
std::cout << *pArrt << "\t" << *(pArrt + 1);    // 004BFB20        004BFB30
```

还是一个地址，但是观察一下这两个地址值相差16个字节，在本机int型实现为4个字节，那么按理来说每个int型元素只会占用4个字节，也就是`*(pArrt + 1)`应该是004BFB24，但是为什么是004BFB30呢？中间的12个字节去哪了？

不要忘了，我们二维数组的每列有4个int型元素，刚好16个字节，这样推论的话，就意味着`*pArrt`应该指的是二维数组第0行的首元素的地址，而`*(pArrt + 1)`指的就是二维数组第1行首元素的地址，因为中间12个字节刚好的第0行剩余三个元素的内存空间。那么相应的第i行的首元素的地址就是`*(pArrt + i)`。那么我们试一下第0行的值是否与上文程序输出一致



```
std::cout << *(*pArrt + 0) << "\t" << *(*pArrt + 1) << "\t" << *(*pArrt + 2) << "\t" << *(*pArrt + 3) << "\t";    // 0       0       0       0
```

完全一致！

那么我们再验证一下第0行的第四个元素的最后一个元素是否是第1行的首元素，如下

```
std::cout << *(pArrt + 0) << "\t" << *(pArrt + 1) << std::endl;
for (int i = 0; i < 5; i++) {
    std::cout << *(pArrt + 0) + i << "\t";
}
```

输出为

```
002EF700        002EF710
002EF700        002EF704        002EF708        002EF70C        002EF710
```

> 注意：由于每次运行都会产生不一样的结果，所以地址是有变化的。

观察一下输出结果的第一行和第二行的最后的地址，一模一样，这也就证明了`*(pArrt + 0)`(也就是`*(pArrt)`)存放的是第0行的首元素的地址，之后跟随的是第0行的剩余的三个元素，由于数组存储在连续地址空间，那么第1行的第一个元素必然紧接着第0行的最后一个元素，在上述代码中，也得到了证明。那么这里都得到了每个元素的地址，在取值一次不就得到了值了嘛！，对的


```
for (int i = 0; i < 5; i++) {
    std::cout << *(*(pArrt + 0) + i) << "\t";
}
```

输出为

```
0       0       0       0       0
```

没问题，综上，我们得出以下结论

+ `*(pArrt + i)`代表的是二维数组第i行的首元素的**地址（注意，这里是地址，不是值）**
+ `*(pArrt + i) + j`代表的就是二维数组第i行第j列的**地址（注意，这里是地址，不是值）**
+ `*(*(pArrt + i) + j)`代表的就是二维数组第i行第j列的**值（现在是值了，因为通过`*`再取值了一次）**

那么pArrt自然代表的就是`*pArrt`的地址，也就是地址的地址，即二维数组首行首元素的地址。

**还有，二维数组的指针这样声明**

```
int(*pArrt)[4];
```

为什么？不能是`int * ar2[4]`吗？

不行，因为`int * ar2[4]`代表的是组织了4个int型指针的数组，其本质是int型指针，而不是数组，数组只是将其组织了起来而已。而`int(*pArrt)[4]`则代表的是二维数组的一行，这一行由4个int型元素组成，其本质是数组，指针是指向该一维数组（就是二维数组的行）的首元素地址，即指向由4个int组成的数组的指针。