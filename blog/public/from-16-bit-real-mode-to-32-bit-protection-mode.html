<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta http-equiv="Cache-Control" content="no-siteapp">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=1, minimum-scale=1, maximum-scale=1">
<meta name="renderer" content="webkit">
<meta name="google" value="notranslate">
<meta name="robots" content="index,follow">


<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Feily Zhang">
<meta name="twitter:description" content="昨夜星辰昨夜风，画楼西畔桂堂东">
<meta name="twitter:image:src" content="https://feily.tech/images/mylogo.png">

<meta property="og:url" content="https://feily.tech">
<meta property="og:title" content="Feily Zhang">
<meta property="og:description" content="昨夜星辰昨夜风，画楼西畔桂堂东">
<meta property="og:site_name" content="Feily Zhang">
<meta property="og:image" content="https://feily.tech/images/mylogo.png">
<meta property="og:type" content="website">
<meta name="robots" content="noodp">

<meta itemprop="name" content="Feily Zhang">
<meta itemprop="description" content="昨夜星辰昨夜风，画楼西畔桂堂东">
<meta itemprop="image" content="https://feily.tech/images/mylogo.png">

<link rel="canonical" href="https://feily.tech">

<link rel="shortcut icon" href="/favicon.png">
<link rel="apple-itouch-icon" href="/favicon.png">
<link rel="stylesheet" href="/bundle/index.css">
<script type="text/javascript">
    var timeSinceLang = {
        year: '年前',
        month: '个月前',
        day: '天前',
        hour: '小时前',
        minute: '分钟前',
        second: '秒前'
    };
    var root = '';
</script>

<script type="text/javascript">
    var conn, reloadTimer, connectTimer;
    var connect = function() {
        conn = new WebSocket('ws://' + location.host + '/live');
        conn.onmessage = function(event) {
            if (event.data === 'change') {
                if (reloadTimer) clearTimeout(reloadTimer);
                reloadTimer = setTimeout(function() {
                    window.location.reload();
                }, 200);
            }
        };
        conn.onclose = function() {
            if (connectTimer) clearTimeout(connectTimer);
            connectTimer = setTimeout(function() {
                connect();
            }, 1000);
        };
    };
    connect();
</script>


        <meta name="keywords" content="Linux,">
        <meta name="description" content="Linux内核源码分析：转变！从16位实模式到32位保护模式">
        <meta name="author" content="林奕清">
        <title>Linux内核源码分析：转变！从16位实模式到32位保护模式</title>
    </head>
    <body>
        <article class="container">
            <header class="header-wrap" style="font-family:Simsun">
  <a class="index" href="/">
    <img class="logo" src="/images/mylogo.png" />
    Feily Zhang
  </a>
  <ul class="menu">
      <li class="menu-item"><a href="/archive.html">归档</a></li>
      <li class="menu-item"><a href="/about.me.html">关于</a></li>
      <li class="menu-item"><a href="/atom.xml">订阅</a></li>
  </ul>
</header>

            <article class="main article">
                <h1 class="title" style="font-family:Simsun">Linux内核源码分析：转变！从16位实模式到32位保护模式</h1>
                <section class="info" style="font-family:KaiTi">
                    <span class="avatar" style="background-image: url(/images/mylogo.png);"></span>
                    <a class="name" href="/about.me.html">林奕清</a>
                    
                    <span class="date" data-time="1577444165"><span class="from"></span></span>
                    
                    <span class="tags">Linux</span>
                </section>
                <article class="content" style="font-family:Kaiti"><h2>回顾</h2>

<p>从上文得知，在BIOS将Linux的磁盘引导程序<code>bootsect</code>加载到<code>0x07C00</code>之后，bootsect开始执行，其先是将自己移动到了<code>0x90000</code>处，然后设置了段寄存器ds、es、ss，后将setup、system程序加载至了指定位置，并确认了根设备号，最终通过段间跳转指令将CPU控制权交给了setup程序。</p>

<p>至此，操作系统的内核程序已经加载完成，但是计算机依旧运行在16位的实模式下，也就意味着只能利用20根地址总线(即<code>0 ~ 19</code>号地址线)，寻址空间仅1MB，也就是寻址范围为<code>0 ~ 0xFFFFF</code>。实模式下的特征是在1MB寻址空间内可以直接软件访问BIOS及周边硬件，但是没有硬件支持的分页机制和实时多任务概念。对于一个现代操作系统来说，这显然是不合适的。因此，从setup开始，做的至关重要的一件事情就是从实模式转变到保护模式下，成为一个真正的现代操作系统。</p>

<h2>一、从BIOS中获取系统数据</h2>

<p>setup做的第一件事就是从BIOS中获取系统数据，并将其保存到<code>0x90000 - 0x901FF</code>的位置。<code>0x90000</code>是bootsect的始址，并不超过<code>0x90200</code>，但是由于bootsect已经完成了任务，所以这段空间可以直接覆盖掉。</p>

<p>先是读取光标位置，通过BIOS中断<code>0x10</code>的<code>0x03</code>号功能来实现，代码如下</p>

<pre><code>! ok, the read went well so we get current cursor position and save it for
! posterity.

    mov ax,#INITSEG ! this is done in bootsect already, but...
    mov ds,ax
    mov ah,#0x03    ! read cursor pos
    xor bh,bh
    int 0x10        ! save it in known place, con_init fetches
    mov [0],dx      ! it from 0x90000.
</code></pre>

<p>该功能号的入口参数为页号码，通过寄存器<code>bx</code>的高八位<code>bh</code>来传递，这里传入的是0，即通过<code>xor</code>运算将<code>bh</code>寄存器清零。</p>

<p>返回的参数包括</p>

<ul>
<li><code>ch</code>，扫描开始线；</li>
<li><code>cl</code>，扫描结束线；</li>
<li><code>dh</code>，行号(<code>0x00</code>是顶端)；</li>
<li><code>dl</code>，列号(<code>0x00</code>是左边)。</li>
</ul>

<p><code>dx</code>寄存器总共两个字节，从<code>0x90000</code>开始保存，即占用<code>0x90000</code>和<code>0x90001</code>两个字节。</p>

<p>接下来获取拓展内存大小(即RAM中高于1MB的部分)，调用<code>0x15</code>中断的<code>0x88</code>功能号实现，代码如下</p>

<pre><code>! Get memory size (extended mem, kB)

    mov ah,#0x88
    int 0x15
    mov [2],ax
</code></pre>

<p>返回值保存在<code>ax</code>寄存器中，共两个字节，保存在<code>0x90002</code>和<code>0x90003</code>中。</p>

<p>接下来读取显卡数据，通过<code>0x10</code>中断的<code>0x0f</code>功能实现，代码如下</p>

<pre><code>! Get video-card data:

    mov ah,#0x0f
    int 0x10
    mov [4],bx      ! bh = display page
    mov [6],ax      ! al = video mode, ah = window width
</code></pre>

<p>返回参数为</p>

<ul>
<li><code>ah</code>，字符列数；</li>
<li><code>al</code>，显示模式；</li>
<li><code>bh</code>，当前显示页。</li>
</ul>

<p>然后分别保存在偏移为<code>4</code>和<code>6</code>的位置。</p>

<p>接下来检查显示方式并取参数，分别通过<code>0x10</code>中断的<code>0x12</code>及<code>0x10</code>功能来实现，代码如下</p>

<pre><code>! check for EGA/VGA and some config parameters

    mov ah,#0x12
    mov bl,#0x10
    int 0x10
    mov [8],ax
    mov [10],bx
    mov [12],cx
</code></pre>

<p>返回参数为</p>

<ul>
<li><code>bh</code>，显示状态(<code>0x00</code>-彩色模式, I/O端口 = <code>0x3dX</code>；<code>0x01</code>-单色模式, I/O端口=<code>0x3bX</code>)；</li>
<li><code>bl</code>，安装的显示内存；</li>
<li><code>cx</code>，显示卡特性参数。</li>
</ul>

<p>然后分别保存在偏移为<code>8</code>, <code>10</code>, <code>12</code>的位置。</p>

<p>接着读取第一个硬盘的信息。需要注意的是，第一个硬盘参数表的首地址是中断向量<code>0x41</code>的向量值，该参数表的长度为16字节，保存的地址始址为<code>0x90080</code>，连续16个字节(<code>0x10</code>)。代码如下</p>

<pre><code>! Get hd0 data

    mov ax,#0x0000
    mov ds,ax
    lds si,[4*0x41]
    mov ax,#INITSEG
    mov es,ax
    mov di,#0x0080
    mov cx,#0x10
    rep
    movsb
</code></pre>

<p>和前面不一样，这里使用<code>es:di</code>来指向传输的目的地址，而<code>ds:si</code>则指向参数表的地址，即源地址。</p>

<p>接下来要读取第二个硬盘的信息，代码逻辑和上述一致，其参数表的地址是中断向量<code>0x46</code>的地址值，由于第一个硬盘参数表刚好保存到<code>0x9008F</code>的位置，那么第二个硬盘的参数表就是从<code>0x90090</code>开始，连续16个字节(<code>0x10</code>)，代码如下</p>

<pre><code>! Get hd1 data

    mov ax,#0x0000
    mov ds,ax
    lds si,[4*0x46]
    mov ax,#INITSEG
    mov es,ax
    mov di,#0x0090
    mov cx,#0x10
    rep
    movsb
</code></pre>

<p>最后要做的是检查系统是否存在第二个硬盘，如果不存在则将上述保存的第二个硬盘参数表清零，代码如下</p>

<pre><code>! Check that there IS a hd1 :-)

    mov ax,#0x01500
    mov dl,#0x81
    int 0x13
    jc  no_disk1
    cmp ah,#3
    je  is_disk1
no_disk1:
    mov ax,#INITSEG
    mov es,ax
    mov di,#0x0090
    mov cx,#0x10
    mov ax,#0x00
    rep
    stosb
</code></pre>

<p>这个过程通过调用中断<code>0x13</code>的<code>0x15</code>号功能来实现。入口参数为<code>dl=驱动器号</code>，其中<code>0x8X</code>表示硬盘、<code>0x80</code>表示第一个硬盘、<code>0x81</code>表示第二个硬盘，那么自然这里必然是<code>0x81</code>。其出口参数为<code>ah=类型码</code>，<code>00</code>表示不存在此盘，并将<code>CF</code>置位；<code>01</code>表示软驱，没有<code>change-line</code>支持；<code>02</code>表示软驱或其它可移动设备，有<code>change-line</code>支持；<code>03</code>表示硬盘。</p>

<p>通过<code>jc</code>指令检查<code>CF</code>是否置位，如果置位即不存在第二个硬盘，那么就跳转至<code>no_disk1</code>处清零第二个参数表。如果存在第二个硬盘，那么<code>jc</code>指令自然不满足则执行<code>cmp</code>指令判断设备是否为硬盘，如果是则将标志寄存器ZF置位(即<code>ah == 03</code>)。再通过<code>je</code>指令判断<code>ZF</code>是否置位，如果置位那么代表设备为硬盘，那么就跳转至<code>is_disk1</code>处继续执行。即</p>

<pre><code>is_disk1:
</code></pre>

<h2>二、关中断！并将system移动至0x00000处</h2>

<p>is_disk1第一句代码就是关中断，如下</p>

<pre><code>is_disk1:

! now we want to move to protected mode ...

    cli         ! no interrupts allowed !
</code></pre>

<p><code>cli</code>指令将CPU标志寄存器中中断允许标志<code>IF</code>置零，即不允许中断。关中断是16位实模式进入32位保护模式的标志性动作，这意味着接下来就可以废除16位实模式下的中断向量表，并初步打开32位寻址空间、建立保护模式下的中断响应机制等，这些都是与32位保护模式相配套的。</p>

<p>作为转变的开始，已经关闭了中断，那么接下来系统将不会响应中断，以便一心一意向保护模式转变。现在开始将system移动至内存始址处，代码如下</p>

<pre><code>! first we move the system to it's rightful place

    mov ax,#0x0000
    cld             ! 'direction'=0, movs moves forward
do_move:
    mov es,ax       ! destination segment
    add ax,#0x1000
    cmp ax,#0x9000
    jz  end_move
    mov ds,ax       ! source segment
    sub di,di
    sub si,si
    mov cx,#0x8000
    rep
    movsw
    jmp do_move
</code></pre>

<p>其中<code>es:di</code>指向目的地址<code>0x0000:0x0</code>处，<code>ds:si</code>指向源地址<code>0x10000:0x0</code>处，由于起初假设system模块不会超过<code>0x80000</code>，即<code>512KB</code>，那么就不会超过<code>0x90000</code>,即system最初不会覆盖bootsect。那么这段程序就是将<code>[0x10000, 0x10000 + 512KB)</code>的内存数据块移动<code>[0x00000, 0x00000 + 512KB)</code>处，移动的数据块长度为<code>0x8000</code>节，即<code>512KB</code>。也就是说将每个源地址字节向内存低端移动<code>0x10000</code>个位置最终到达目标位置，上述汇编代码可以用如下伪码描述</p>

<pre><code>ax = 0x0000
while truees = ax
    ax += 0x1000
    ds = ax
    di = si = 0x0
    ds:si to es:di, moving one seg continuously, i.e. 64KB
    if ax + 0x1000 == 0x9000
        break
</code></pre>

<p>再进一步地说明，上述伪码中各参数变动情况如下所示(注：下述<code>while</code>循环用来解释上述中的<code>ds:si to es:di, moving one seg continuously, i.e. 64KB</code>)</p>

<pre><code>The first cycle is as follows:
  es = 0x0000, ax = 0x1000, ds = 0x1000, di = 0x0, si = 0x0, cx = 0x8000
    while cx != 0x0000
      ds:si to es:di, one word at a time, i.e. movsw
        cx -= 0x0001

The second cycle is as follows:
  es = 0x1000, ax = 0x2000, ds = 0x2000, di = 0x0, si = 0x0, cx = 0x8000
    while cx != 0x0000
      ds:si to es:di, one word at a time, i.e. movsw
        cx -= 0x0001
...
</code></pre>

<p>这就很容易理解了。那么该段汇编就可以整体上用如下伪码描述</p>

<pre><code>ax = 0x0000
while truees = ax
    ax += 0x1000
    ds = ax
    di = si = 0x0
    cx = 0x8000
    while cx != 0x0000
        ds:si to es:di, one word at a time, i.e. movsw
        cx -= 0x0001
    if ax + 0x1000 == 0x9000
        break
</code></pre>

<p>至此，就完成了对system模块的移动。对system模块的移动起到了如下的效果</p>

<ul>
<li>废除了BIOS中断向量表，等同于废除了BIOS所提供的实模式下的中断服务程序；</li>
<li>回收已经无用的内存空间，因为要向保护模式转变，BIOS中断向量表所占空间自然无用，应当回收；</li>
<li>让system模块占据内存物理地址最天然、有利的位置。</li>
</ul>

<h2>三、设置IDT与GDT</h2>

<p>与实模式不同的是，保护模式下的段寻址是通过GDT(Global Descriptor Table, 全局描述符表)完成的，GDT中存放的是段寄存器内容，其数据结构为数组。GDT在操作系统进程切换中意义重大，其中存放了每个任务的LDT(Local Descriptor Table, 局部描述符表)地址和TSS(Task Structure Segment, 任务状态段)地址，以完成进程中各段的寻址、现场保护与现场恢复。</p>

<p>GDT的初始内容已经写在了setup程序中，如下</p>

<pre><code>gdt:
    .word   0,0,0,0     ! dummy

    .word   0x07FF      ! 8Mb - limit=2047 (2048*4096=8Mb)
    .word   0x0000      ! base address=0
    .word   0x9A00      ! code read/exec
    .word   0x00C0      ! granularity=4096, 386

    .word   0x07FF      ! 8Mb - limit=2047 (2048*4096=8Mb)
    .word   0x0000      ! base address=0
    .word   0x9200      ! data read/write
    .word   0x00C0      ! granularity=4096, 386
</code></pre>

<p>可以整理为如下一张表</p>

<pre><code> index |    GDT
------------------
   2   | 00C0 9200
       | 0000 07FF
------------------
   1   | 00C0 9A00
       | 0000 07FF
------------------
   0   | 0000 0000
       | 0000 0000
</code></pre>

<p>其中每个GDT表项共64位，即8字节，结构如下</p>

<pre><code>31------------------------------16-15-----------------------0
             Base 0:15            |         Limit 0:15
63--------56-55---52-51---------48-47---------40-39--------32
 Base 24:31 | Flags | Limit 16:19 | Access Byte | Base 16:23
</code></pre>

<p>Access Byte的结构如下</p>

<pre><code>8---7-------5---4----3----2----1---0
 Pr | Privl | 1 | Ex | Dc | RW | Ac
</code></pre>

<p>Flags的结构如下</p>

<pre><code>8---7----6---5--4
 Gr | Sz | 0 | 0
</code></pre>

<p>特别说明的<code>Privl</code>为特权级，如果为<code>00</code>表示内核特权级，如果为<code>11</code>，则表明用户特权级；<code>Gr</code>标志位为颗粒度标志，如果为1，那么段限长的单位为4KB，如果为0，那么就是1B。可见，GDT将段基址与段限长拆分保存在不连续的bit位中。这是为了兼容286架构。那么现在GDT表项就很容易理解了。</p>

<p>以第一项GDT为例，其内容为</p>

<pre><code>00C0 9A00
0000 07FF
</code></pre>

<p>第<code>0-15bit</code>与<code>48-51bit</code>构成段限长，内容为</p>

<pre><code>007FF
</code></pre>

<p>将其转换为10进制就是2047bit，即2KB；再看一下颗粒度标志，其包含在最后一个字节，即</p>

<pre><code>00C0    // 00000000 11000000
</code></pre>

<p>可见，颗粒度标志位的值为1，那么也就意味着段限长实际上为<code>0x007FF * 4KB = 8MB</code>。确定了段限长，我们再确定一下段基址，<code>16-31bit</code>, <code>32-39bit</code>, <code>56-63bit</code>构成了段基址，那么合起来就是</p>

<pre><code>0x0000000
</code></pre>

<p>即内存始址。</p>

<p>现在我们知道了GDT的内容与含义，那么设置GDT就是将GDT表的始址保存在GDTR(Global Descriptor Table Register, GDT基地址寄存器)中，通过下述指令完成</p>

<pre><code>lidt    idt_48      ! load idt with 0,0
</code></pre>
</article>
                <section class="author" style="font-family:NSimSun">
                    <div class="avatar" style="background-image: url(/images/mylogo.png);"></div>
                    <a class="name" href="/about.me.html">林奕清</a>
                    <div class="intro" style="font-family:KaiTi">If not now, when? If not me, who?</div>
                </section>
                <section class="recommend" style="font-family:KaiTi">
                    
                    
                    <section class="nav next">
                        <div class="head">下篇文章</div>
                        <a class="link" href="/is-lm-analysis-of-the-effect-of-fiscal-policy-and-monetary-policy.html">财政政策效果和货币政策效果的IS-LM分析</a>
                    </section>
                    
                </section>
                
            </article>
        </article>
        <footer class="footer" style="font-family:Consolas">
    <span class="copyright">
        Feily Zhang ©
        <script type="text/javascript">
            document.write(new Date().getFullYear());
        </script>
    </span>
    <span class="publish">Powered by <a href="http://www.chole.io/" target="_blank">Ink</a></span>
</footer>

        <script src="/bundle/index.js"></script>
    </body>
</html>
