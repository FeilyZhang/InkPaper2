title: "计算机操作系统原理总结(一)——处理器管理"
date: 2019-07-03 20:58:14 +0800
update: 2019-07-03 20:58:14 +0800
author: me
cover: "-/images/os.jpg"
tags:
    - OS
preview: 进程的定义、特征、模型；进程控制块（PCB）的作用、信息及组织方式；进程的控制；进程对临界资源访问的互斥性与进程间的同步；利用信号量实现同步示例；进程通信；死锁。

---

## 一、进程的定义、特征、模型

#### 1.1 进程的概念

进程是一个可并发执行的、具有独立功能的程序关于某个数据集合的一次执行过程，也是操作系统进行资源分配与保护的基本单位。

#### 1.2 进程的属性：

+ 结构性：进程包含了数据集合和运行于其上的程序，每个进程至少包含三个组成要素：数据块、程序块、进程控制块（PCB）；
+ 共享性：同一程序运行于不同数据集合上构成不同的进程；
+ 动态性：进程由创建而产生、被调度而执行、被撤销而消亡；
+ 独立性：进程是操作系统中资源分配与保护的基本单位，也是系统调度的独立单位；
+ 制约性：并发进程之间存在着制约关系，进程在执行的关键点上需要相互等待、互通消息；
+ 并发性：在单处理器环境下，各个进程轮流占用处理器。

#### 1.3 进程的三态模型：

![进程三态模型](/images/article/jinchengsantai.jpg)

+ 就绪态：进程具备运行条件，等待系统分配处理器以便运行；
+ 运行态：进程占用处理器正在运行；
+ 阻塞态：进程不具备运行条件,正在等待某个事件完成。

#### 1.4 进程的五态模型：

在进程三态模型的基础上，引入新建态与终止态：

![进程五态模型](/images/article/jinchengwutai.jpg)

+ 新建态：创建一个进程，正在等待操作系统完成创建进程的必要操作；
+ 终止态：进程已经终止，不再参与处理器竞争。

## 二、进程控制块（PCB）的作用、信息及组织方式

#### 2.1 PCB的作用

操作系统依靠PCB感知进程的存在，PCB是进程存在的唯一标志；

#### 2.2 PCB的信息

+ 描述信息：进程标识符、用户名或用户标识符、家族关系；
+ 控制信息：当前状态、优先级、程序开始地址、各种计时信息、通信信息；
+ 资源管理信息；
+ CPU现场保护机构。

#### 2.3 组织方式

+ 链接队列方式：就绪、运行、阻塞队列，排队原则与调度策略有关；
+ 索引表方式：就绪、运行、阻塞索引表。

## 三、进程的控制

进程的控制是典型的事件驱动，即进程的创建、撤销及阻塞或被唤醒是由特定事件触发的。

## 四、进程对临界资源访问的互斥性与进程间的同步

#### 4.1 临界资源的定义

并发进程可以共享进程中的各种资源，但是系统中某些资源具有一次仅允许一个进程使用的特点，这样的资源被称为临界资源。

#### 4.2 临界资源的访问

对于系统中的临界资源，应保证进程的互斥访问，方法就是进行进程间的同步，同步应该遵循以下原则：独立平等、空闲让进、互斥进入、让权等待、有限等待。

#### 4.3 进程间同步的三种方法

+ 加锁/开锁原语；
+ 信号量与P、V原语
+ 管程

在操作系统中利用信号量来表征一种资源或状态，通过对信号量值的改变来表征进程对资源的使用状况，或判断信号量的值来控制进程的状态。**信号量按取值分为以下两种**：

+ 二元信号量：仅允许取值为0或1，主要用于解决***进程互斥***问题；
+ 一般信号量：初值常常为可用资源数，可以大于1，多用来进行***进程同步***。

对**信号量S定义**如下：

1. S是一个整型变量且初值非负；
2. 对信号量仅能实施P(S)、V(S)操作，也只有这两种操作才能改变S的值；
3. 每个信号量都对应一个等待队列，队列中的进程处于等待状态。

**P原语的操作定义**如下：

1. S减一；
2. 若S减一后仍大于等于零，则进程继续执行；
3. 若S减一后小于零，则该进程被阻塞进入该信号的等待队列中，然后转进程调度。

**V原语的操作定义**如下：

1. S加1；
2. 若S加一后结果大于零，则进程继续执行；
3. 若S加一后结果小于等于零，则从该信号量的等待队列中唤醒一个等待进程，然后再返回原进程继续执行或转进程调度。

**<u>综上，对信号量以及P、V操作的伪代码描述如下：</u>**

```
typedef struct semaphore {
    int value;    // 信号量值
    struct pcb *list;    // 信号量队列指针
} semaphore;

void P(semaphore &s) {
    s.value--;    // 执行一次P操作，代表索取一个资源，代表资源的信号量值减一
    if (s.value < 0 ) W(s.list);    // 如果value值减一后小于0那么说明暂时没有该类资源可供使用，该进程进入阻塞队列
}

void V(semaphore &s) {
    s.value++;    // 执行一次V操作，代表释放一个资源，信号量value值加一
    if (s.value <= 0) R(s.list);	   // 如果value值<=0，那么说明有进程因无法获取资源而阻塞，所以去阻塞队列唤醒一个
}
```

需要注意的是**P、V操作具有严格的不可分割性**，有两层含义：

+ 信号量是系统中的公共变量，对某一信号量的操作必须是互斥的；
+ P、V操作是一对操作，若有对信号量S的P操作，那么必须也有对信号量S的V操作，反之亦然。

那么，**<u>利用信号量实现互斥的方法</u>**为：为临界区资源设一个信号量`mutex`，初值为`1`，将临界区置于`P(mutex)`和`V(mutex)`之间，`P(mutex)`和`V(mutex)`一定要成对出现在同一个进程中。伪代码描述为

```
semaphore mutex;
mutex = 1;
cobegin
process Pi() {
    P(mutex);
	{对临界区的具体操作};
	V(mutex);
}
coend
```

以上互斥为二元信号量，可以看出等同于显式锁的加锁与释放，即某进程在对共享变量进行操作时，需要执行P操作(等同于加锁)，操作完毕时需要执行V操作(等同于释放锁)。那么对于**<u>代表可用资源数目的一般信号量应该如何描述</u>**呢？

代表可用资源数目的一般信号量的P、V操作一般分散在各个进程中，以生产者-消费者为例，生产者每执行一次生产操作，对于代表缓冲区商品数目个数的信号量full来说就需要执行一次V操作，代表生产的可用资源数目加一，相对应地，对于代表商品缓冲区空缓冲区的个数的信号量empty来说，就需要执行一次P操作，含义为每生产一次空缓冲区数目减一。相对应的，消费者进程则是对full信号量执行P操作代表消费一次缓冲区数目减少一个，empty信号量执行V操作，代表消费一次，缓冲区空闲多一个。

**<p style="color:red">总而言之，多进程环境下对于临界区的操作必须使用互斥信号量进行同步（参见伪代码描述），而对于代表可用资源数目的一般信号量，则由多进程相互配合完成。</p>**

**<u>拓展阅读：</u>**<p style="border:1px dotted black">**P、V操作的物理意义**：在共享同一类资源的具有相互合作关系的进程之间，信号量的初值用来表示系统中同类资源的可用数目。因此当信号量S等于0时，表示没有空闲的该类资源可用；S < 0时，其绝对值表示因请求该类资源而被阻塞的进程数，每执行一次P操作意味着请求分配一个单位的某类资源，因此描述为S = S - 1；若S < 0表示已无该类资源可供分配，因此把该进程加入到与S相关的等待队列中。进程使用完某类资源后必须执行一次V操作，意味着释放一个单位的该类资源，因此描述为S = S + 1；若S <= 0表示已有进程在等待该类资源，因此唤醒等待队列中的第一个或优先级最高的进程，允许其使用该类资源。</p>

## 五、利用信号量实现同步示例

#### 5.1 哲学家进餐问题

问题描述：有5个哲学家围坐在一张圆桌旁，桌面中央有一盘通心面，每个人面前有一只空盘子，每两个人之间放一把叉子。每个哲学家思考、饥饿、吃面。为了吃面，每个哲学家必须获得两把叉子，且每人只能从自己左边或右边取叉子，如图所示

![哲学家进餐及引起思索](/images/article/zhexuejiajincan.jpg)

解决方案：

1. 至多允许4位哲学家同时去拿左边的叉子，保证至少有一位哲学家能够进餐；
2. 规定奇数号哲学家先拿其左边的叉子，再拿其右边的叉子；偶数号哲学家先拿其右边的叉子，再拿其左边的叉子；
3. 仅当哲学家的左右两把叉子均可使用时，才允许他进餐，否则一把叉子也不取。

#### 5.2 生产者-消费者问题

问题描述：指存在数据供给与需求的两类进程。实现生产者-消费者问题的数据结构设计如下：

1. 含有n个缓冲区的公用缓冲池；
2. 互斥信号量mutex：实现诸进程对缓冲池的互斥使用，一次仅允许一个进程读或写公用缓冲池，初值为1；
3. 资源信号量empty：记录空缓冲区的个数，初值为n；
4. 资源信号量full：记录满缓冲区的个数，初值为0.

算法描述如下

```
item B[k];
semaphore empty;
empty = k;    // 可以使用的空缓冲区数目
semaphore full;
full = 0;    // 缓冲区内可以使用的产品数
semaphore mutex;
mutex = 1;    // 互斥信号量
int in = 0;    // 写缓冲区指针
int out = 0;    // 读缓冲区指针

cobegin
process producer_i () {    // 生产者进程
    while (true) {
        produce();    // 先生产
        P(empty);    // 由于生产了一个，那么可用缓冲区数目减一，对应P操作
        P(mutex);    // 对临界区的操作必须互斥，执行mutex的P操作
        append to B[in];
        in = (in + 1) % k;
        V(mutex);    // 执行mutex的V操作
        V(full);    // 生产完毕，可使用产品数加一，对应V操作
    }
}

process producer_i () {    // 消费者进程
    while (true) {
        P(full);    // 因为是消费，所以可用产品数减一，对应full的P操作
        P(mutex);    // 临界区互斥操作，执行mutex的P操作
        take() from B[out];
        out = (out + 1) % k;
        V(mutex);    // 执行mutex的V操作
        V(empty);    // 因为消费了，所以空缓冲区数目加一，对应empty的V操作
		consume();    // 消费
    }
}
coend
```

可见，每个进程中对互斥信号量mutex的操作是成对出现的，而对于一般信号量的操作是进程间成对出现的，代表资源的获取与释放（特指在生产者-消费者中）。

#### 5.3 读者-写者问题

问题描述：若干读者（Reader）进程和写者（Writer）进程共享一个数据文件，允许多个Reader进程同时读一个共享对象，但不允许一个Writer进程与其他Reader进程或者Writer进程同时访问共享对象。也就是说：

1. 允许多个读者同时进行操作；
2. 只允许一个写者执行写操作；
3. 任一写者在完成写操作之前不允许其他读者或者写者访问共享文件；
4. 写者执行写操作前，应让已有的写者和读者全部退出。

算法分析如下：

1. 互斥信号量writeblock：用于Reader与Writer、Writer与Writer之间的互斥，初值为1；
2. readcount：登记正在读的进程的数目，初值为0；
3. 互斥信号量mutex：用于Reader与Reader互斥访问整型量readcount，初值为1；

readcount情况分析：

1. 如果readcount为0，则可能有也可能没有写者在写；
2. 如果读者数目readcount不为0，则不会有写者在写，请求读的读者可以进行读操作；
3. 如果读者数目readcount为0，又没有写者在写，则请求写的写者才可以进行写操作。

算法描述如下：

```
int readcount = 0;
semaphore writeblock, mutex;
writeblock = 1;
mutex = 1;
cobegin
process reader_i() {
    P(mutex);    // 互斥操作，开始
    readcount++;    // 由于是读操作，所以读进程数量加一
    if (readcount == 1) P(writeblock);    // 如果读进程数量为1，即不为1，那么说明不会有写者在写，所以没必要加信号量，即下一步执行互斥信号量的V操作
    V(mutex);    // 执行mutex的V操作
    {具体读文件操作};    // 然后进行具体的读操作
    P(mutex);    // 对共享变量readcount操作需要加信号量，因为每次读进程操作都会修改这个值，上面的代码也是同理
    readcount--;    // 文件读完之后读进程数量减一
    if(readcount == 0) V(writeblock);    // 如果减一后值为0，且当前进程是读者进程说明没有写者在写，所以执行writeblock的V操作，释放一个写者进程进行写操作
    V(mutex);    // 互斥信号量成对出现，所以必须执行V操作
}

// 由于读操作没有涉及共享变量readcount，所以不用为共享变量readcount加信号量
process writer_j() {
    P(writeblock);    // 写进程执行写操作，需要向信号量申请，即执行P操作（信号量writeblock代表资源数目，不管是互斥信号量还是一般信号量都可以理解为资源数目）
    {具体写文件操作};    // 申请到了，执行具体的写操作
    V(writeblock);    // 写完后释放占用的资源，供其余进程申请
}
coend
```

#### 5.4 睡眠理发师问题

问题描述：理发店有一位理发师、一把理发椅和n把椅子供顾客等候理发休息。如果没有顾客，理发师便在理发椅上睡觉。某位顾客到来时，该顾客必须叫醒理发师。如果理发师正在理发时又有顾客到来，则如果有空椅子可坐，顾客就坐下来等待，否则离开。

算法描述如下：

```
int waiting = 0;    // 等待的顾客数目，为共享变量
int CHAIRS = N;    // 为顾客准备的椅子数目
semaphore customers, barbers, mutex;
customers = 0, barbers = 0, mutex = 1;
cobegin
process barber() {
    while (true) {
        P(customers);    // 申请顾客（相当于加锁），如果没有顾客即申请不到，那么就阻塞即睡眠，不会再往下执行
        P(mutex);    // 理发师要对共享变量操作，所以必须申请保护
        waiting--;    // 理发一位，减一
        V(barbers);    // 已经理发完了，所以解除理发师资源的占用，也就是可以为下一个理发了
        V(mutex);    // 对共享变量的操作完毕，释放信号量占用
        cut_hair();
    }
}

process customer_i() {
    P(mutex);    // 因为涉及对共享变量waiting的操作，所以需要申请资源，以便临界区保护
    if (waiting < CHAIRS) {    // 如果椅子没有坐满，那么就继续执行
        waiting++;    // 等待的人数目加一
        V(customers);    // 对代表顾客资源数目的信号量加一，代表多了一个顾客
        V(mutex);    // 对临界区资源操作完毕，可以释放信号量
        P(barbers);    // 顾客申请理发师，即执行P操作，如果申请不到则坐下来（阻塞），否则就理发
        get_haircut();
    } else V(mutex);    // 如果椅子满了，什么也不做（离开）
}
coend
```

## 六、进程通信

+ 共享变量
+ 共享内存
+ 消息传递通信机制
+ 套接字通信机制：不同主机的进程实现通信的方式；
+ 管道：是连接进程的一个共享文件，允许进程以先进先出的方式写入和读出数据，并对读写操作进行同步。

## 七、死锁

#### 7.1 死锁产生的必要条件

1. 互斥条件：进程互斥使用资源，一旦某个资源被占用，则要使用该资源的进程必须等待；
2. 占有和等待条件：进程申请新资源得不到满足而等待时，不释放已占用资源；
3. 不剥夺条件：一个进程不能抢占其他进程占有的资源；
4. 循环等待条件：存在一组进程循环等待资源的现象。

#### 7.2 死锁防止

只需要破坏上述条件即可，如下

1. 破坏互斥条件：破坏互斥条件使资源可同时访问而不是互斥使用，对于进程同步来说，该条件不能破坏反而要加以保证；
2. 破坏占有和等待条件：通过静态分配可以实现。静态分配指的是一个进程必须在执行前申请它所需要的全部资源，并且直到它需要的资源都得到满足后才开始执行；
3. 破坏不剥夺条件：当进程在申请资源未得到的情况下，主动释放资源，然后去等待；
4. 破坏循环等待条件：采用层次分配策略可以实现。层次分配策略指的是将资源分成多个层次，当进程得到某一层的某个资源后，它只能申请较高层次的资源。当进程要释放某层次的资源时，必须先释放占有的较高层次的资源。当进程得到某一层的一个资源后，它想申请该层的另一个资源时，必须先释放该层中的已占有资源。

#### 7.3 银行家算法的基本思想

1. 每个客户必须预先说明自己要求的最大资金量；
2. 每个客户每次提出部分资金量申请和获得分配；
3. 如果银行满足了客户对资金的最大需求量，则客户在资金运作后一定可以很快归还资金。。

采用银行家算法思想考虑死锁问题时，操作系统对应银行家，操作系统管理的资源对应周转资金，进程对应要求贷款的客户。

银行家算法的缺点是，很难在运行前知道其所需的最大资源量，而且算法要求系统中的进程必须是无关的，相互间没有同步要求，进程的个数和分配的资源数目应该是固定的。这些要求事先难以满足，因此该算法缺乏实用价值。

#### 7.4 死锁的检测与解除

解决死锁问题的一个途径是死锁的检测与解除，这种方法对资源的分配不加任何限制，也不采取死锁避免措施（即不采取上述四个破坏条件），但系统定时运行一个“死锁检测程序”，判断系统内是否出现死锁，如果出现，则采取措施解除它。

死锁的解除方法如下

1. 立即结束所有进程的执行，并重启操作系统；
2. 剥夺陷于死锁的进程占用的资源，但不撤销它，直到死锁解除；
3. 撤销陷于死锁的所有进程，解除死锁以继续运行；
4. 逐个撤销陷于死锁的进程，回收其资源，直至死锁解除；
5. 根据系统保存的检查点，使所有进程回退，直到足以解除死锁；
6. 当检测到死锁时，如果存在某些未卷入死锁的进程，而这些进程随着建立一些新的抑制进程能执行到结束，则它们可能释放足够的资源来解除死锁。

> 参考《操作系统原理与Linux实践教程》 / 申丰山 王黎明 编著