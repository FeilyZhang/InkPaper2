[{"content":"\r\n\r\n面向接口编程通过结合IoC和DI，使得耦合性相当低，可拓展性极强，实现了低耦合高内聚，但是这种编程方式是对功能性主业务需求的分而治之，对于一些非功能性的需求则显得力不从心，比如日志、安全、事务、性能统计等次要但很必要的功能就显得不够省力。\r\n\r\n我们在软件系统设计的时候，一项很重要的工作就是把一个大系统按业务功能分解成一个个低耦合、高内聚的模块，分而治之，但是分解之后就会发现，有些非功能性需求的东西是通用的或者说是跨越多个模块的，即多个模块都需要，比如\r\n\r\n1. 日志：对特定的操作输出日志来记录； \r\n2. 安全：在执行操作之前进行权限的检查； \r\n3. 事务：在方法开始之前要开始事务，在方法结束之后要提交或者回滚事务；\r\n4. 性能统计：统计每个方法的执行时间\r\n5. ......\r\n\r\n这些多个模块都需要的非功能性需求用面向接口编程的方式实现是很不优雅的，但是用面向切面的编程方式来实现则方便很多。\r\n\r\n主业务功能性需求我们可以看作是一个个面，每层叠加在一起构成了一个面包，这个面包就是整个需求，由于每个面都需要一些非功能性需求(诸如日志、安全等等)，那么这些需求就像一个切面一样贯穿到了主业务需求的每层面包当中，即非功能性代码与业务代码的关注点不同，业务代码的关注点是必要性功能的实现(面向接口更简单，强调的是可拓展性)，非功能性代码的关注点是通用性非必要功能的实现，采用面向切面的方式更简单，即非功能性代码与业务代码之间应该是正交的(垂直的)。\r\n\r\n把通用性非功能性代码的实现方式就叫做面向切面编程，切面是贯穿于业务代码的。这就是AOP\r\n\r\n先说明几个简单的概念\r\n\r\n1. 切入点或连接点：如果切面要切入业务代码的某个方法，那么这个方法就是切面的切入点； \r\n2. 通知：由于切面是对业务代码通用性非必要功能的抽象，那么以日志为例，比如日志切面要切入业务需求User类的print()方法，那么就要在该方法执行之前和之后记录日志，这就要用到通知，通知就是对切入方法的前置、后置和环绕等操作；\r\n3. 目标：即切面切入的方法所在的类就是目标，例如User类就是目标。\r\n\r\n通过一个简单的例子来说明之\r\n\r\nUser类如下，该类通过Setter方式接受参数创建bean\r\n```\r\npackage springTest;\r\n\r\npublic class User {\r\n    \r\n    String userName;\r\n    \r\n    public void setUserName(String userName) {\r\n        this.userName = userName;\r\n    }\r\n    \r\n    public String getUserName() {\r\n        return userName;\r\n    }\r\n    \r\n    public void print() {\r\n        System.out.println(\"I am \" + userName);\r\n    }\r\n    \r\n}\r\n```\r\n配置文件如下\r\n```\r\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\n\u003cbeans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:p=\"http://www.springframework.org/schema/p\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\"\r\n    xmlns:util=\"http://www.springframework.org/schema/util\" \r\n    xmlns:aop=\"http://www.springframework.org/schema/aop\"             \r\n    xsi:schemaLocation=\"                                               \r\n            http://www.springframework.org/schema/beans \r\n            http://www.springframework.org/schema/beans/spring-beans.xsd    \r\n            http://www.springframework.org/schema/context     \r\n            http://www.springframework.org/schema/context/spring-context.xsd    \r\n            http://www.springframework.org/schema/mvc    \r\n            http://www.springframework.org/schema/mvc/spring-mvc.xsd  \r\n            http://www.springframework.org/schema/tx   \r\n            http://www.springframework.org/schema/tx/spring-tx.xsd  \r\n            http://www.springframework.org/schema/aop  \r\n            http://www.springframework.org/schema/aop/spring-aop.xsd\"\u003e\r\n\u003cbean id=\"u\" class=\"springTest.User\"\u003e\r\n    \u003cproperty name=\"userName\" value=\"Java\"/\u003e\t\u003c!-- 传递参数创建bean --\u003e\r\n\u003c/bean\u003e\r\n\u003c/beans\u003e\r\n```\r\n主文件如下\r\n```\r\npackage springTest;\r\n\r\nimport org.springframework.context.ApplicationContext;\r\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\r\n\r\npublic class UserMain {\r\n\r\n    public static void main(String[] args) {\r\n        ApplicationContext factory = new ClassPathXmlApplicationContext(\"springTest/userBean.xml\");\r\n        User user = (User) factory.getBean(\"u\");\r\n        user.print();\r\n    }\r\n\r\n}\r\n```\r\n运行结果为\r\n```\r\nI am Java\r\n```\r\n假如我们现在要给目标User类的print方法记录操作日志，那么就需要一个切面，定义如下\r\n```\r\npackage springTest;\r\n\r\nimport java.util.Date;\r\n\r\npublic class Log {\r\n\r\n    public void beforeExecute() {\r\n        System.out.println(\"Log : \" + new Date() + \"User类的print方法即将执行\");\r\n    }\r\n    \r\n    public void afterExecute() {\r\n        System.out.println(\"Log : \" + new Date() + \"User类的print方法已经执行\");\r\n    }\r\n}\r\n```\r\n可以看出，其实就是一个简单的Java类，定义了两个方法，在目标方法执行之前执行beforeExecute()方法记录日志，在目标方法执行之后执行afterExecute()方法记录日志，但是并没有看到切面Log作用在目标User类之上啊？？？稍安勿躁，这些都是配置文件完成的，如下\r\n```\r\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\n\u003cbeans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:p=\"http://www.springframework.org/schema/p\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\"\r\n    xmlns:util=\"http://www.springframework.org/schema/util\" \r\n    xmlns:aop=\"http://www.springframework.org/schema/aop\"             \r\n    xsi:schemaLocation=\"                                               \r\n            http://www.springframework.org/schema/beans \r\n            http://www.springframework.org/schema/beans/spring-beans.xsd    \r\n            http://www.springframework.org/schema/context     \r\n            http://www.springframework.org/schema/context/spring-context.xsd    \r\n            http://www.springframework.org/schema/mvc    \r\n            http://www.springframework.org/schema/mvc/spring-mvc.xsd  \r\n            http://www.springframework.org/schema/tx   \r\n            http://www.springframework.org/schema/tx/spring-tx.xsd  \r\n            http://www.springframework.org/schema/aop  \r\n            http://www.springframework.org/schema/aop/spring-aop.xsd\"\u003e\r\n\u003cbean id=\"u\" class=\"springTest.User\"\u003e\r\n    \u003cproperty name=\"userName\" value=\"Java\"/\u003e\r\n\u003c/bean\u003e\r\n\u003cbean id=\"log\" class=\"springTest.Log\"/\u003e\r\n\u003caop:config proxy-target-class=\"true\" \u003e\r\n\u003caop:aspect ref=\"log\"\u003e\r\n    \u003caop:pointcut id=\"place-order\" expression=\"execution( * springTest.User.print(..))\"/\u003e\r\n    \u003caop:before pointcut-ref=\"place-order\" method=\"beforeExecute\"/\u003e\r\n    \u003caop:after pointcut-ref=\"place-order\" method=\"afterExecute\"/\u003e\r\n\u003c/aop:aspect\u003e\r\n\u003c/aop:config\u003e\r\n\u003c/beans\u003e\r\n```\r\n我们通过`\u003cbean id=\"log\" class=\"springTest.Log\"/\u003e`创建了切面Log的bean实例，然后通过`\u003caop:aspect ref=\"log\"\u003e`将切面Log的实例log作为切面，然后定义切入点pointcut为sprintTest包内User类的print方法(代号为place-order)，即切面作用于该方法，只通知该方法，然后对该切入点place-order绑定前置和后置操作，即beforeExecute方法和afterExecute方法记录User类print方法的日志\r\n\r\n其余代码不变，然后运行，结果为\r\n```\r\nLog : Thu Dec 13 19:57:21 CST 2018User类的print方法即将执行\r\nI am Java\r\nLog : Thu Dec 13 19:57:21 CST 2018User类的print方法已经执行\r\n```\r\n很明显，日志记录成功。\r\n\r\n如果我们要监控User类中的其他方法那怎么办？\r\n\r\n我们不妨再给User类中再增加两个方法，如下\r\n```\r\npackage springTest;\r\n\r\npublic class User {\r\n    \r\n    String userName;\r\n    \r\n    public void setUserName(String userName) {\r\n        this.userName = userName;\r\n    }\r\n    \r\n    public String getUserName() {\r\n        return userName;\r\n    }\r\n    \r\n    public void print() {\r\n        System.out.println(\"I am \" + userName);\r\n    }\r\n    \r\n    public void print1() {\r\n        System.out.println(\"I am \" + userName + \" 1\");\r\n    }\r\n\r\n    public void print2() {\r\n        System.out.println(\"I am \" + userName + \" 2\");\r\n    } \r\n}\r\n```\r\n其实我们只需要修改配置文件切面的作用域即可，如下\r\n```\r\n\u003caop:pointcut id=\"place-order\" expression=\"execution( * springTest.User.*(..))\"/\u003e\r\n```\r\n然后再在主文件中调用一下其余两个方法就可以看到效果了\r\n```\r\npackage springTest;\r\n\r\nimport org.springframework.context.ApplicationContext;\r\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\r\n\r\npublic class UserMain {\r\n\r\n    public static void main(String[] args) {\r\n        ApplicationContext factory = new ClassPathXmlApplicationContext(\"springTest/userBean.xml\");\r\n        User user = (User) factory.getBean(\"u\");\r\n        user.print();\r\n        user.print1();\r\n        user.print2();\r\n    }\r\n\r\n}\r\n```\r\n结果为\r\n```\r\nLog : Thu Dec 13 20:00:46 CST 2018User类的print方法即将执行\r\nI am Java\r\nLog : Thu Dec 13 20:00:46 CST 2018User类的print方法已经执行\r\nLog : Thu Dec 13 20:00:46 CST 2018User类的print方法即将执行\r\nI am Java 1\r\nLog : Thu Dec 13 20:00:46 CST 2018User类的print方法已经执行\r\nLog : Thu Dec 13 20:00:46 CST 2018User类的print方法即将执行\r\nI am Java 2\r\nLog : Thu Dec 13 20:00:46 CST 2018User类的print方法已经执行\r\n```\r\n怎么样，简单吧？如果要给其它类也要记录日志怎么办？同样修改作用域，将类名部分用通配符*代替即可。\r\n\r\n这是一个较为简单优雅的AOP实例，还有一个更为复杂的，不妨也看一下(这个是真的复杂)\r\n\r\n假定我们现在有一个银行账户Account类，里面有add和minus方法，要给这两个方法加日志功能，包括前置、后置和环绕操作，那么首先要先定义一个Account接口\r\n```\r\npackage springTest;\r\n\r\npublic interface Account {\r\n    void add(int money);\r\n    void minus(int money);\r\n}\r\n```\r\n再实现这个接口\r\n```\r\npackage springTest;\r\n\r\npublic class AccountImpl implements Account {\r\n\r\n    private String name;\r\n    \r\n    public String getName() {\r\n        return name;\r\n    }\r\n    \r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n    \r\n    @Override\r\n    public void add(int money) {\r\n        System.out.println(\"给\" + name + \"账户加钱\" + money + \"元\");\r\n    }\r\n\r\n    @Override\r\n    public void minus(int money) {\r\n        System.out.println(\"给\" + name + \"账户扣钱\" + money + \"元\");\r\n    }\r\n\r\n}\r\n```\r\n那么，我们切面的目标就是这个Account接口的实现类AccountImpl。接下来定义前置、后置和环绕类及方法，如下\r\n```\r\npackage springTest;\r\n\r\nimport java.lang.reflect.Method;\r\nimport org.springframework.aop.MethodBeforeAdvice;\r\n\r\n\r\npublic class BeforeAdvice implements MethodBeforeAdvice {\r\n\r\n    public void before(Method m, Object[] args, Object target) throws Throwable {\r\n        System.out.println(\"在方法调用前\");\r\n        System.out.println(\"执行的方法是\" + m);\r\n        System.out.println(\"方法的参数是\" + args[0]);\r\n        System.out.println(\"目标对象是：\" + target);\r\n    }\r\n}\r\n\r\npackage springTest;\r\n\r\nimport java.lang.reflect.Method;\r\n\r\npublic class AfterAdvice implements org.springframework.aop.AfterAdvice {\r\n\r\n    public void afterReturning(Object returnValue, Method m, Object[] args, Object target) throws Throwable {\r\n        System.out.println(\"在方法调用后\");\r\n        System.out.println(\"执行的方法是\" + m);\r\n        System.out.println(\"方法的参数是\" + args[0]);\r\n        System.out.println(\"目标对象是：\" + target);\r\n        \r\n    }\r\n}\r\n\r\npackage springTest;\r\n\r\nimport org.aopalliance.intercept.MethodInterceptor;\r\nimport org.aopalliance.intercept.MethodInvocation;\r\n\r\npublic class AroundInterceptor implements MethodInterceptor {\r\n\r\n    @Override\r\n    public Object invoke(MethodInvocation arg0) throws Throwable {\r\n        System.out.println(\"调用方法之前：invocation对象：[\"+ arg0 + \"]\");\r\n        Object rval = arg0.proceed();\r\n        System.out.println(\"调用结束...\");\r\n        return rval;\r\n    }\r\n\r\n}\r\n```\r\n主文件为\r\n```\r\npackage springTest;\r\n\r\nimport org.springframework.context.ApplicationContext;\r\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\r\n\r\npublic class AOPMain {\r\n\r\n    public static void main(String[] args) {\r\n        ApplicationContext factory = new ClassPathXmlApplicationContext(\"springTest/AOPBean.xml\");\r\n        Account account = (Account) factory.getBean(\"account\");\r\n        System.out.println(\"第一个add方法\");\r\n        account.add(100);\r\n        System.out.println(\"第二个minus方法\");\r\n        account.minus(200);\r\n    }\r\n\r\n}\r\n```\r\n同样的，通过配置文件绑定切面和目标，如下\r\n```\r\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\n\u003cbeans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:p=\"http://www.springframework.org/schema/p\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\"\r\n    xmlns:util=\"http://www.springframework.org/schema/util\"\r\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd\r\n        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\r\n        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.3.xsd\"\u003e\r\n\r\n\u003c!-- 先给目标对象注入参数以创建bean --\u003e\r\n\u003cbean id=\"accountTarget\" class=\"springTest.AccountImpl\"\u003e\r\n    \u003cproperty name=\"name\" value=\"Java\" /\u003e\r\n\u003c/bean\u003e\r\n\r\n\u003c!-- 再配置前置、环绕bean --\u003e\r\n\u003cbean id=\"myBeforeAdvice\" class=\"springTest.BeforeAdvice\"/\u003e\r\n\u003cbean id=\"myAroundInterceptor\" class=\"springTest.AroundInterceptor\"/\u003e\r\n\r\n\u003c!-- 后置bean比较特殊，将20行的后置bean包装在id为addAdvisor的bean当中，并指定patterns使该后置bean只作用在add方法上，对其他方法没有作用 --\u003e\r\n\u003cbean id=\"addAdvisor\" class=\"org.springframework.aop.support.RegexpMethodPointcutAdvisor\"\u003e\r\n    \u003cproperty name=\"advice\"\u003e\r\n        \u003cbean class=\"springTest.AfterAdvice\"/\u003e\r\n    \u003c/property\u003e\r\n    \u003cproperty name=\"patterns\"\u003e\r\n        \u003clist\u003e\r\n            \u003cvalue\u003e.*add*.\u003c/value\u003e\t\u003c!-- 只对add方法管用 --\u003e\r\n        \u003c/list\u003e\r\n    \u003c/property\u003e\r\n\u003c/bean\u003e\r\n\r\n\u003c!-- 以上是配置前后置及环绕bean --\u003e\r\n\u003c!-- 以下是绑定切面(通知)和目标 --\u003e\r\n\r\n\u003cbean id=\"account\" class=\"org.springframework.aop.framework.ProxyFactoryBean\"\u003e\r\n    \u003cproperty name=\"proxyInterfaces\" value=\"springTest.Account\"/\u003e\r\n    \u003cproperty name=\"target\"\u003e\t\u003c!-- 切面的目标是id为accountTarget的bean类，即上面定义的 --\u003e\r\n        \u003cref bean=\"accountTarget\"/\u003e\r\n    \u003c/property\u003e\r\n    \u003cproperty name=\"interceptorNames\"\u003e\t\u003c!-- 拦截器列表，对目标方法拦截以记录日志 --\u003e\r\n        \u003clist\u003e\r\n            \u003cvalue\u003emyBeforeAdvice\u003c/value\u003e\r\n            \u003cvalue\u003emyAroundInterceptor\u003c/value\u003e\r\n        \u003c/list\u003e\r\n    \u003c/property\u003e\r\n\u003c/bean\u003e\r\n\u003c/beans\u003e\r\n```\r\n执行结果为\r\n```\r\n第一个add方法\r\n在方法调用前\r\n执行的方法是public abstract void springTest.Account.add(int)\r\n方法的参数是100\r\n目标对象是：springTest.AccountImpl@12c8a2c0\r\n调用方法之前：invocation对象：[ReflectiveMethodInvocation: public abstract void springTest.Account.add(int); target is of class [springTest.AccountImpl]]\r\n给Java账户加钱100元\r\n调用结束...\r\n第二个minus方法\r\n在方法调用前\r\n执行的方法是public abstract void springTest.Account.minus(int)\r\n方法的参数是200\r\n目标对象是：springTest.AccountImpl@12c8a2c0\r\n调用方法之前：invocation对象：[ReflectiveMethodInvocation: public abstract void springTest.Account.minus(int); target is of class [springTest.AccountImpl]]\r\n给Java账户扣钱200元\r\n调用结束...\r\n```\r\n很明显，这种方法很繁琐，我们完全可以将其改造一下，如下\r\n\r\n目标类Account，为了与上文区分(下同)，我们定义为Accounts，如下\r\n```\r\npackage springTest;\r\n\r\npublic class Accounts {\r\n\r\n    private String name;\r\n    \r\n    public String getName() {\r\n        return name;\r\n    }\r\n    \r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n    \r\n    public void add(int money) {\r\n        System.out.println(\"给\" + name + \"账户加钱\" + money + \"元\");\r\n    }\r\n\r\n    public void minus(int money) {\r\n        System.out.println(\"给\" + name + \"账户扣钱\" + money + \"元\");\r\n    }\r\n\r\n}\r\n```\r\n切面类，我们定义为AccountsLog，如下\r\n```\r\npackage springTest;\r\n\r\nimport java.lang.reflect.Method;\r\n\r\nimport org.aopalliance.intercept.MethodInterceptor;\r\nimport org.aopalliance.intercept.MethodInvocation;\r\nimport org.springframework.aop.MethodBeforeAdvice;\r\n\r\npublic class AccountsLog implements \r\n    MethodBeforeAdvice, org.springframework.aop.AfterAdvice, MethodInterceptor {\r\n\r\n    @Override\r\n    public Object invoke(MethodInvocation arg0) throws Throwable {\r\n        System.out.println(\"调用方法之前：invocation对象：[\"+ arg0 + \"]\");\r\n        Object rval = arg0.proceed();\r\n        System.out.println(\"调用结束...\");\r\n        return rval;\r\n    }\r\n\r\n    @Override\r\n    public void before(Method m, Object[] args, Object target) throws Throwable {\r\n        System.out.println(\"在方法调用前\");\r\n        System.out.println(\"执行的方法是\" + m);\r\n        System.out.println(\"方法的参数是\" + args[0]);\r\n        System.out.println(\"目标对象是：\" + target);\r\n    }\r\n\r\n\r\n    public void afterReturning(Object returnValue, Method m, Object[] args, Object target) throws Throwable {\r\n        System.out.println(\"在方法调用后\");\r\n        System.out.println(\"执行的方法是\" + m);\r\n        System.out.println(\"方法的参数是\" + args[0]);\r\n        System.out.println(\"目标对象是：\" + target);\r\n        \r\n    }\r\n}\r\n```\r\n该类实现了三个接口，分别是前置，后置和环绕接口，因为我们要拿到相应的参数，所以必须实现接口并重写方法，如果不拿参数，自己写即可不需要实现接口\r\n\r\n配置文件为\r\n```\r\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\n\u003cbeans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:p=\"http://www.springframework.org/schema/p\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\"\r\n    xmlns:util=\"http://www.springframework.org/schema/util\" \r\n    xmlns:aop=\"http://www.springframework.org/schema/aop\"             \r\n    xsi:schemaLocation=\"                                               \r\n            http://www.springframework.org/schema/beans \r\n            http://www.springframework.org/schema/beans/spring-beans.xsd    \r\n            http://www.springframework.org/schema/context     \r\n            http://www.springframework.org/schema/context/spring-context.xsd    \r\n            http://www.springframework.org/schema/mvc    \r\n            http://www.springframework.org/schema/mvc/spring-mvc.xsd  \r\n            http://www.springframework.org/schema/tx   \r\n            http://www.springframework.org/schema/tx/spring-tx.xsd  \r\n            http://www.springframework.org/schema/aop  \r\n            http://www.springframework.org/schema/aop/spring-aop.xsd\"\u003e\r\n\u003cbean id=\"acc\" class=\"springTest.Accounts\"\u003e\r\n    \u003cproperty name=\"userName\" value=\"Java\"/\u003e\r\n\u003c/bean\u003e\r\n\u003cbean id=\"log\" class=\"springTest.AccountsLog\"/\u003e\r\n\u003caop:config proxy-target-class=\"true\" \u003e\r\n\u003caop:aspect ref=\"log\"\u003e\r\n    \u003caop:around pointcut=\"execution(* springTest.Accounts.*(..))\" method=\"invokev\" /\u003e\r\n    \u003caop:before pointcut=\"execution(* springTest.Accounts.*(..))\" method=\"before\"/\u003e\r\n    \u003caop:after pointcut=\"execution(* springTest.Accounts.*(..))\" method=\"afterReturning\"/\u003e\r\n\u003c/aop:aspect\u003e\r\n\u003c/aop:config\u003e\r\n\u003c/beans\u003e\r\n```\r\n这次我们并没有像第一个例子一样单独定义切入点，而是对不同的通知类型单独定义，其实完全可以提出来，这样做是为了演示这种方式，主文件为\r\n```\r\npackage springTest;\r\n\r\nimport org.springframework.context.ApplicationContext;\r\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\r\n\r\npublic class AccountsMain {\r\n\r\n    public static void main(String[] args) {\r\n        ApplicationContext factory = new ClassPathXmlApplicationContext(\"springTest/accountsBean.xml\");\r\n        Account account = (Account) factory.getBean(\"account\");\r\n        System.out.println(\"第一个add方法\");\r\n        account.add(100);\r\n        System.out.println(\"第二个minus方法\");\r\n        account.minus(200);\r\n    }\r\n\r\n}\r\n```\r\n运行结果为\r\n```\r\n第一个add方法\r\n在方法调用前\r\n执行的方法是public abstract void springTest.Account.add(int)\r\n方法的参数是100\r\n目标对象是：springTest.AccountImpl@12c8a2c0\r\n调用方法之前：invocation对象：[ReflectiveMethodInvocation: public abstract void springTest.Account.add(int); target is of class [springTest.AccountImpl]]\r\n给Java账户加钱100元\r\n调用结束...\r\n第二个minus方法\r\n在方法调用前\r\n执行的方法是public abstract void springTest.Account.minus(int)\r\n方法的参数是200\r\n目标对象是：springTest.AccountImpl@12c8a2c0\r\n调用方法之前：invocation对象：[ReflectiveMethodInvocation: public abstract void springTest.Account.minus(int); target is of class [springTest.AccountImpl]]\r\n给Java账户扣钱200元\r\n调用结束...\r\n```\r\n怎么样？完美无缺！！！\r\n\r\n需要特别注意的是AOP的使用，不仅仅要用Spring官方给出的jar，还需要两个jar，分别从这里下载\r\n\r\n+ [https://www.findjar.com/jar/aopalliance/jars/aopalliance-1.0.jar.html](https://www.findjar.com/jar/aopalliance/jars/aopalliance-1.0.jar.html)\r\n+ [http://maven.outofmemory.cn/org.aspectj/aspectjweaver/1.7.4/](http://maven.outofmemory.cn/org.aspectj/aspectjweaver/1.7.4/)\r\n","cover":"/images/Spring-Framework.jpg","link":"analysis-of-aspect-oriented-programming.html","preview":"\u003cp\u003e把通用性非功能性代码的实现方式就叫做面向切面编程，切面是贯穿于业务代码的，这就是AOP。\u003c/p\u003e\n","title":"面向切面编程(Aspect Oriented Programming)浅析"},{"content":"\r\n\r\n第一种方式，(无参创建)通过无参构造器创建一个bean实例\r\n```\r\npackage springTest;\r\n\r\npublic class Product {\r\n\t/*\r\n    public Product() {\r\n        \r\n    }*/\r\n    public void printProduct1() {\r\n        System.out.println(\"Hello, I am product1!\");\r\n    }\r\n\r\n    public void printProduct2() {\r\n        System.out.println(\"Hello, I am product2!\");\r\n    }\r\n}\r\n```\r\n其中默认构造器可以省略，即使没有那么Java类在编译期间也会自动填充一个默认构造器\r\n\r\n然后是配置文件\r\n```\r\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\n\u003cbeans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:p=\"http://www.springframework.org/schema/p\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\"\r\n    xmlns:util=\"http://www.springframework.org/schema/util\"\r\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd\r\n        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\r\n        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.3.xsd\"\u003e\r\n\u003cbean name=\"pro\" class=\"springTest.Product\"/\u003e\r\n\u003c/beans\u003e\r\n```\r\n再是主方法类\r\n```\r\nackage springTest;\r\n\r\nimport org.springframework.context.ApplicationContext;\r\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\r\n\r\npublic class ProductMain {\r\n\r\n    public static void main(String[] args) {\r\n        ApplicationContext factory = new ClassPathXmlApplicationContext(\"springTest/productBean.xml\");\r\n        Product product = (Product) factory.getBean(\"pro\", Product.class);\r\n        product.printProduct1();\r\n        product.printProduct2();\r\n    }\r\n}\r\n```\r\n运行结果为\r\n```\r\nHello, I am product1!\r\nHello, I am product2!\r\n```\r\n这里并不会牵扯到依赖注入，因为只是一个类，并没有类之间的依赖关系，所以和正常的Java类一样，不需要编写依赖注入时被注入类的set/get方法。\r\n\r\n但是如果类有构造器而且不是默认构造器，该怎么办？用第一种方法是会报错的，如下\r\n```\r\nException in thread \"main\" org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'pro' defined in class path resource [springTest/productBean.xml]: Instantiation of bean failed; nested exception is org.springframework.beans.BeanInstantiationException: Could not instantiate bean class [springTest.Product]: No default constructor found; nested exception is java.lang.NoSuchMethodException: springTest.Product.()\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateBean(AbstractAutowireCapableBeanFactory.java:1076)\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1021)\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:504)\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:475)\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:302)\r\n\tat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:228)\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:298)\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:193)\r\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:703)\r\n\tat org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:760)\r\n\tat org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:482)\r\n\tat org.springframework.context.support.ClassPathXmlApplicationContext.(ClassPathXmlApplicationContext.java:139)\r\n\tat org.springframework.context.support.ClassPathXmlApplicationContext.(ClassPathXmlApplicationContext.java:83)\r\n\tat springTest.ProductMain.main(ProductMain.java:9)\r\nCaused by: org.springframework.beans.BeanInstantiationException: Could not instantiate bean class [springTest.Product]: No default constructor found; nested exception is java.lang.NoSuchMethodException: springTest.Product.()\r\n\tat org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:85)\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateBean(AbstractAutowireCapableBeanFactory.java:1069)\r\n\t... 13 more\r\nCaused by: java.lang.NoSuchMethodException: springTest.Product.()\r\n\tat java.lang.Class.getConstructor0(Unknown Source)\r\n\tat java.lang.Class.getDeclaredConstructor(Unknown Source)\r\n\tat org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:80)\r\n\t... 14 more\r\n```\r\n这种情况下第二种方法就显得很有必要了\r\n\r\n第二种方法，(有参通过构造器创建)通过配置文件向构造器传递参数实例化bean\r\n\r\n我们先将Product类改为有构造器参与的形式\r\n```\r\npackage springTest;\r\n\r\npublic class Product {\r\n    \r\n    String product1;\r\n    String product2;\r\n    \r\n    public Product(String product1, String product2) {\r\n        this.product1 = product1;\r\n        this.product2 = product2;\r\n    }\r\n    \r\n    public void printProduct1() {\r\n        System.out.println(\"Hello, I am \" + product1);\r\n    }\r\n\r\n    public void printProduct2() {\r\n        System.out.println(\"Hello, I am \" + product2);\r\n    } \r\n}\r\n```\r\n再通过配置文件传递参数实例化bean(其实就是实例化类)\r\n```\r\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\n\u003cbeans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:p=\"http://www.springframework.org/schema/p\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\"\r\n    xmlns:util=\"http://www.springframework.org/schema/util\"\r\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd\r\n        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\r\n        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.3.xsd\"\u003e\r\n\u003cbean name=\"pro\" class=\"springTest.Product\"\u003e\r\n    \u003cconstructor-arg index=\"0\" value=\"product1\"/\u003e\r\n    \u003cconstructor-arg index=\"1\" value=\"product2\"/\u003e\r\n\u003c/bean\u003e\r\n\u003c/beans\u003e\r\n```\r\n以上配置文件的bean标签的constructor-arg标签的index属性等同于name属性，如下\r\n```\r\n\u003cbean name=\"pro\" class=\"springTest.Product\"\u003e\r\n    \u003cconstructor-arg name=\"product1\" value=\"product1\"/\u003e\r\n    \u003cconstructor-arg name=\"product2\" value=\"product2\"/\u003e\r\n\u003c/bean\u003e\r\n```\r\n是同样的功能\r\n\r\n再运行之\r\n```\r\npackage springTest;\r\n\r\nimport org.springframework.context.ApplicationContext;\r\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\r\n\r\npublic class ProductMain {\r\n\r\n    public static void main(String[] args) {\r\n        ApplicationContext factory = new ClassPathXmlApplicationContext(\"springTest/productBean.xml\");\r\n        Product product = (Product) factory.getBean(\"pro\", Product.class);\r\n        product.printProduct1();\r\n        product.printProduct2();\r\n    }\r\n}\r\n```\r\n结果为\r\n```\r\nHello, I am product1\r\nHello, I am product2\r\n```\r\n当然这只是向一个bean传递参数的一种方式，还有一种方式是通过Setter方式\r\n\r\n第三种，(有参通过Setter方式创建)通过Setter方式传递参数给bean创建其实例\r\n\r\n这种方法自然要对相应的字段编写对应的get/set方法，如下\r\n```\r\npackage springTest;\r\n\r\npublic class Product {\r\n    \r\n    String product1;\r\n    String product2;\r\n    /*\r\n    public Product(String product1, String product2) {\r\n        this.product1 = product1;\r\n        this.product2 = product2;\r\n    }\r\n    */\r\n    public String getProduct1() {\r\n        return product1;\r\n    }\r\n    \r\n    public String getProduct2() {\r\n        return product2;\r\n    }\r\n    \r\n    public void setProduct1(String product1) {\r\n        this.product1 = product1;\r\n    }\r\n    \r\n    public void setProduct2(String product2) {\r\n        this.product2 = product2;\r\n    }\r\n    \r\n    public void printProduct1() {\r\n        System.out.println(\"Hello, I am \" + product1);\r\n    }\r\n\r\n    public void printProduct2() {\r\n        System.out.println(\"Hello, I am \" + product2);\r\n    } \r\n}\r\n```\r\n配置文件只需要把constructor-arg标签改为property即可，如下\r\n```\r\n\u003cbean name=\"pro\" class=\"springTest.Product\"\u003e\r\n    \u003cproperty name=\"product1\" value=\"product1\"/\u003e\r\n    \u003cproperty name=\"product2\" value=\"product2\"/\u003e\r\n\u003c/bean\u003e\r\n```\r\n主文件不做改动，仍然是同样的运行结果\r\n\r\n这种情况下你可以注释掉构造器，前提是你没有使用constructor-arg标签传递参数。当然，你也可以二者都使用，如下\r\n```\r\npackage springTest;\r\n\r\npublic class Product {\r\n    \r\n    String product1;\r\n    String product2;\r\n    \r\n    public Product(String product1) {\r\n        this.product1 = product1;\r\n    }\r\n    \r\n    public String getProduct2() {\r\n        return product2;\r\n    }\r\n    public void setProduct2(String product2) {\r\n        this.product2 = product2;\r\n    }\r\n    \r\n    public void printProduct1() {\r\n        System.out.println(\"Hello, I am \" + product1);\r\n    }\r\n\r\n    public void printProduct2() {\r\n        System.out.println(\"Hello, I am \" + product2);\r\n    } \r\n}\r\n\u003cbean name=\"pro\" class=\"springTest.Product\"\u003e\r\n    \u003cconstructor-arg name=\"product1\" value=\"product1\"/\u003e\r\n    \u003cproperty name=\"product2\" value=\"product2\"/\u003e\r\n\u003c/bean\u003e\r\npackage springTest;\r\n\r\nimport org.springframework.context.ApplicationContext;\r\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\r\n\r\npublic class ProductMain {\r\n\r\n    public static void main(String[] args) {\r\n        ApplicationContext factory = new ClassPathXmlApplicationContext(\"springTest/productBean.xml\");\r\n        Product product = (Product) factory.getBean(\"pro\", Product.class);\r\n        product.printProduct1();\r\n        product.printProduct2();\r\n    }\r\n}\r\n```\r\n此外，这里配置文件的属性用的是name而不是id，这两者都可以用而且主文件中`factory.getBean(\"pro\", Product.class)`与`factory.getBean(\"pro\")`是同样的功能，可以自由组合。","cover":"/images/Spring-Framework.jpg","link":"several-ways-to-create-bean-instances-in-spring.html","preview":"\u003cp\u003e无参默认构造器、有参自定义构造器、有参通过Setter方式创建。\u003c/p\u003e\n","title":"Spring中创建Bean实例的几种方式"},{"content":"\r\n\r\n就是变动一下配置文件，改为\r\n```\r\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\n\u003cbeans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:p=\"http://www.springframework.org/schema/p\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\"\r\n    xmlns:util=\"http://www.springframework.org/schema/util\"\r\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd\r\n        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\r\n        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.3.xsd\"\u003e\r\n\u003cbean id=\"helloWorldSpring\" class=\"HelloWorldSpring\"/\u003e    \u003c!-- 注意注入类的id可以随意定义，无需与被注入类字段保持一致 -\u003e\r\n\u003cbean id=\"sayHello\" class=\"SayHello\" /\u003e\r\n\u003ccontext:annotation-config /\u003e    \u003c!-- 注意这里的代码 --\u003e\r\n\u003c/beans\u003e\r\n```\r\n再在被注入类字段上进行注解\r\n```\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\n\r\npublic class SayHello {\r\n    \r\n    @Autowired\r\n    private HelloWorldSpring helloWorldSpring;\r\n    public HelloWorldSpring getHelloWorldSpring() {\r\n        return helloWorldSpring;\r\n    }\r\n    public void setHelloWorldSpring(HelloWorldSpring helloWorldSpring) {\r\n        this.helloWorldSpring = helloWorldSpring;\r\n    }\r\n    public void sayHello() {\r\n        System.out.println(\"Say Hello:\" + helloWorldSpring.sayHello());\r\n    }\r\n}\r\n```\r\n这种注入方式等同于autowire=\"byType\"。只不过尽可能少用这种方式，缺点如下\r\n\r\n+ 代码可读性差，不容易维护，因为类之间的依赖关系我们只能在代码中找\r\n+ 通用性不好，如果我们哪天不用Spring了，那么我们就得一个个删除注解。","cover":"/images/Spring-Framework.jpg","link":"spring-assembly-via-autowire-annotation.html","preview":"\u003cp\u003eAutowired按byType自动注入，而Resource默认按 byName自动注入。\u003c/p\u003e\n","title":"通过@Autowired注解进行Spring装配"},{"content":"\r\n\r\n先说明，以下是公用代码，只是配置文件不同\r\n```\r\npublic class HelloWorldSpring {\r\n    private String sayContent;\r\n    public String sayHello() {\r\n        System.out.println(\"HelloWorld Spring!\");\r\n        return \"HelloWorld Spring\";\r\n    }\r\n}\r\n\r\npublic class SayHello {\r\n    private HelloWorldSpring helloWorldSpring;\r\n    public HelloWorldSpring getHelloWorldSpring() {\r\n        return helloWorldSpring;\r\n    }\r\n    public void setHelloWorldSpring(HelloWorldSpring helloWorldSpring) {\r\n        this.helloWorldSpring = helloWorldSpring;\r\n    }\r\n    public void sayHello() {\r\n        System.out.println(\"Say Hello:\" + helloWorldSpring.sayHello());\r\n    }\r\n}\r\n\r\nimport org.springframework.context.ApplicationContext;\r\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\r\n\r\npublic class SpringMain {\r\n\r\n    public static void main(String[] args) {\r\n        ApplicationContext factory = new ClassPathXmlApplicationContext(\"bean.xml\");\r\n        SayHello sayHello = (SayHello) factory.getBean(\"sayHello\");\r\n        sayHello.sayHello();\r\n    }\r\n\r\n}\r\n```\r\nSpring的注入方式有六种，比较常用的有三种自动装配\r\n\r\n第一种自动装配，当被注入类配置文件bean标签中属性autowire的取值为no时，表明不使用自动装配，即必须显式的使用\u003cref\u003e标签明确的指定注入的bean\r\n```\r\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\n\u003cbeans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:p=\"http://www.springframework.org/schema/p\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\"\r\n    xmlns:util=\"http://www.springframework.org/schema/util\"\r\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd\r\n        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\r\n        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.3.xsd\"\u003e\r\n\u003cbean id=\"helloWorldSpring\" class=\"HelloWorldSpring\"/\u003e\r\n\u003cbean id=\"sayHello\" class=\"SayHello\" autowire=\"no\"\u003e    \u003c!-- 请注意这里的autowire属性及其值 --\u003e\r\n    \u003cproperty name=\"helloWorldSpring\" ref=\"helloWorldSpring\"/\u003e    \u003c!-- 还有这里的property标签 --\u003e\r\n\u003c/bean\u003e\r\n\u003c/beans\u003e\r\n```\r\n可见，这种方式无异于脱了裤子放屁，直接去掉autowire属性即可，就和前几篇文章用的注入方式一致\r\n\r\n第二种自动装配，当被注入类配置文件bean标签中属性autowire的取值为byName时，表明根据属性名自动装配，那么将会检查Spring容器，根据名字查找属性完全一致的Bean然后进行注入。简言之就是与被注入类中字段名称相同的配置文件中的bean标签的id值代表的class类对象将会被装配(注入)，如下\r\n```\r\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\n\u003cbeans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:p=\"http://www.springframework.org/schema/p\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\"\r\n    xmlns:util=\"http://www.springframework.org/schema/util\"\r\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd\r\n        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\r\n        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.3.xsd\"\u003e\r\n\u003cbean id=\"helloWorldSpring\" class=\"HelloWorldSpring\"/\u003e\r\n\u003cbean id=\"sayHello\" class=\"SayHello\" autowire=\"byName\"\u003e    \u003c!-- 请注意这里的autowire属性及其值 --\u003e\r\n\u003c/bean\u003e\r\n\u003c/beans\u003e\r\n```\r\n第三种自动装配，当被注入类配置文件bean标签中属性autowire的取值为byType时，表明按类型自动装配，即被注入类字段的数据类型(为类)与配置文件中bean标签的注入类class属性的类型名一致时，才会装配，如下\r\n```\r\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\n\u003cbeans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:p=\"http://www.springframework.org/schema/p\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\"\r\n    xmlns:util=\"http://www.springframework.org/schema/util\"\r\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd\r\n        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\r\n        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.3.xsd\"\u003e\r\n\u003cbean id=\"helloWorldSpring\" class=\"HelloWorldSpring\"/\u003e\r\n\u003cbean id=\"sayHello\" class=\"SayHello\" autowire=\"byType\"\u003e    \u003c!-- 请注意这里的autowire属性及其值 --\u003e\r\n\u003c/bean\u003e\r\n\u003c/beans\u003e\r\n```\r\n需要特别注意的是，被注入类中的相关字段一定要有对应的set方法(和get方法)，不然byName和byType会报错NPE,no和以前的那种装配方式则会报错如下\r\n```\r\nCaused by: org.springframework.beans.NotWritablePropertyException: Invalid property 'helloWorldSpring' of bean class [SayHello]: Bean property 'helloWorldSpring' is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter?\r\n```","cover":"/images/Spring-Framework.jpg","link":"three-other-common-ways-of-spring-injection-and-autowire.html","preview":"\u003cp\u003eSpring的注入方式有六种，比较常用的有三种自动装配。\u003c/p\u003e\n","title":"Spring注入的另外三种常用方式与AutoWire"},{"content":"\r\n\r\nSpring中读取配置文件的三种方式\r\n```\r\nResource res = new ClassPathResource(\"packageName/bean.xml\");\r\nBeanFactory factory = new XmlBeanFactory(res);    //通过XmlBeanFactory类读取\r\n\r\nApplicationContext factory = new ClassPathXmlApplicationContext(\"packageName/bean.xml\");    //通过ClassPathXmlApplicationContext类读取\r\n\r\nApplicationContext factory = new FileSystemXmlApplicationContext(new String[] {\"bean.xml的绝对路径\"})\r\n或者\r\nApplicationContext factory = new FileSystemXmlApplicationContext(\"bean.xml的绝对路径\")    //通过FileSystemXmlApplicationContext类读取\r\n```\r\n单例Bean就是Main文件在运行中只会得到一个Bean实例，即每次得到的Bean实例是相同的，也称无状态Bean，一般把公用的资源可以保存为单例Bean；\r\n\r\n多例Bean就是Main文件在运行中每getBean()都会得到一个截然不同的Bean实例，也称有状态Bean，那么就可以用有状态Bean来保存比较私有的资源。\r\n\r\n单例和多例Bean可以在配置文件中的bean标签中设置，需要特别注意的是，旧版Spring中是通过singleton属性来设置的，当值为true时为单例无状态Bean，当值为false时为多例有状态Bean；在新版Spring中，是通过scope属性来设置的，当值为prototype时为有状态多例Bean，当值为singleton时为单例无状态Bean。\r\n\r\n一个简单的例子来说明单例和多例Bean\r\n\r\n这是一个提供随机数的类\r\n```\r\npackage springTest;\r\n\r\npublic class Randoms {\r\n    private int i  = (int) (100 * Math.random());\r\n    public void printRandom() {\r\n        System.out.println(i);\r\n    }\r\n}\r\n```\r\n配置文件设置其为多例Bean，由于和其它类没有依赖关系，所以只需要定义bean即可，无需定义其他的属性\r\n```\r\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\n\u003cbeans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:p=\"http://www.springframework.org/schema/p\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\"\r\n    xmlns:util=\"http://www.springframework.org/schema/util\"\r\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd\r\n        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\r\n        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.3.xsd\"\u003e\r\n\u003cbean id=\"ran\" class=\"springTest.Randoms\" scope=\"prototype\"/\u003e\r\n\u003c/beans\u003e\r\npackage springTest;\r\n\r\nimport org.springframework.context.ApplicationContext;\r\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\r\n\r\npublic class SpringRandoms {\r\n\r\n    public static void main(String[] args) {\r\n        ApplicationContext factory = new ClassPathXmlApplicationContext(\"springTest/RandomsBean.xml\");\r\n        Randoms r1 = (Randoms)factory.getBean(\"ran\");\r\n        Randoms r2 = (Randoms)factory.getBean(\"ran\");\r\n        System.out.println(r1 == r2);\r\n        r1.printRandom();\r\n        r2.printRandom();\r\n    }\r\n\r\n}\r\n```\r\n运行结果为\r\n```\r\nfalse\r\n28\r\n15\r\n```\r\n通过配置文件将其设置为单例Bean，如下\r\n```\r\n\u003cbean id=\"ran\" class=\"springTest.Randoms\" scope=\"singleton\"/\u003e\r\n```\r\n那么运行结果为\r\n```\r\ntrue\r\n93\r\n93\r\n```","cover":"/images/Spring-Framework.jpg","link":"spring-reads-configuration-files-in-three-ways-single-and-multiple-beans.html","preview":"\u003cp\u003eSpring中读取配置文件的三种方式。\u003c/p\u003e\n","title":"Spring中读取配置文件的三种方式及单例多例Bean"},{"content":"\r\n\r\n所谓Spring依赖注入，指的是类之间对象实例的传递方式。传统的类间对象(或参数)传递是通过实例化一个类，然后将该对象传递给另一个类的方法,而依赖注入则是通过配置文件将一个类的实例直接传递给另一个类的变量或者方法，根本不用显式的new对象然后再作为参数传递。如下\r\n```\r\npublic class SayHello {\r\n    private HelloWorldSpring helloWorldSpring;\r\n    public HelloWorldSpring getHelloWorldSpring() {\r\n        return helloWorldSpring;\r\n    }\r\n    public void setHelloWorldSpring(HelloWorldSpring helloWorldSpring) {\r\n        this.helloWorldSpring = helloWorldSpring;\r\n    }\r\n    public void sayHello() {\r\n        System.out.println(\"Say Hello:\" + helloWorldSpring.sayHello());\r\n    }\r\n}\r\npublic class HelloWorldSpring {\r\n    private String sayContent;\r\n    public String sayHello() {\r\n        System.out.println(\"HelloWorld Spring!\");\r\n        return \"HelloWorld Spring\";\r\n    }\r\n}\r\npublic class HelloMain {\r\n\r\n    public static void main(String[] args) {\r\n        SayHello sayHello = new SayHello();\r\n        // new实例然后传递给调用者，耦合度高\r\n        sayHello.setHelloWorldSpring(new HelloWorldSpring());\r\n        sayHello.sayHello();\r\n    }\r\n\r\n}\r\n```\r\n以上HelloMain是传统的注入方式，明显耦合度高，但是依赖注入可不这么干，是通过配置文件来实现注入，如下\r\n```\r\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\n\u003cbeans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:p=\"http://www.springframework.org/schema/p\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\"\r\n    xmlns:util=\"http://www.springframework.org/schema/util\"\r\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd\r\n        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\r\n        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.3.xsd\"\u003e\r\n\u003cbean id=\"helloWorldSpring\" class=\"HelloWorldSpring\"/\u003e\r\n\u003cbean id=\"sayHello\" class=\"SayHello\"\u003e\r\n    \u003cproperty name=\"helloWorldSpring\" ref=\"helloWorldSpring\"/\u003e\r\n\u003c/bean\u003e\r\n\u003c/beans\u003e\r\nimport org.springframework.context.ApplicationContext;\r\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\r\n\r\npublic class SpringMain {\r\n    public static void main(String[] args) {\r\n        ApplicationContext factory = new ClassPathXmlApplicationContext(\"bean.xml\");\r\n        SayHello sayHello = (SayHello) factory.getBean(\"sayHello\");\r\n        sayHello.sayHello();\r\n    }\r\n}\r\n```\r\n`ApplicationContext factory = new ClassPathXmlApplicationContext(\"bean.xml\")`读取配置文件，然后通过getBean()方法获取一个目标为sayHello的对象，其实就是通过配置文件实例化了SayHello类，sayHello对应bean.xml文件里的SayHello类的id。\r\n\r\n特别注意的是此处代码并没有在包中(一个空包，即文件头没有package声明)，所以bean文件中bean标签的class属性并没有加包名前缀，同理SpringMain读取配置文件也没有加包名路径。\r\n\r\n以上就是Spring依赖注入。\r\n\r\n至于Spring控制反转，则说的是类的实例化不用通过new显式的实现，而是将创建对象的控制权由自写代码交给Spring容器(或Spring jar包)，即控制反转。上述SpringMain可以明显的看出，sayHello对象的创建是通过`factory.getBean()`方法实现的，而不是new操作符。\r\n\r\n简言之，控制反转说的是类的初始化(创建)不用new而交给Spring容器，依赖注入说的是通过配置文件实现类间的对象传递。其目的就是解耦.\r\n\r\n再通过面向接口编程深入理解IoC与DI\r\n\r\n面向接口编程的本质是缩小修改的影响范围,先看一个实际的例子，有一个提供随机数生成的类，有一个专门使用随机数的类，如果用常规思维来实现的话，无非就是如下的代码\r\n```\r\npackage springTest;\r\n\r\npublic class Random {\r\n    private int randomNum = (int) (50 * Math.random());\r\n    public void printRandom() {\r\n        System.out.println(randomNum);\r\n    }\r\n}\r\npackage springTest;\r\n\r\npublic class TestMain {\r\n    public static void main(String[] args) {\r\n        new Random().printRandom();\r\n    }\r\n}\r\n```\r\n而面向接口编程则是如下的代码\r\n\r\n先是接口，向外部调用者提供用于返回Random对象的createRandom方法\r\n```\r\npackage springTest;\r\n\r\npublic interface HelloInterface {\r\n    public abstract Random createRandom();\r\n}\r\n```\r\n再是接口的实现，外部调用者通过createRandom得到Random对象时，是直接和接口打交道，根本不知道有该实现类的存在\r\n```\r\npackage springTest;\r\n\r\npublic abstract class HelloAbstract implements HelloInterface {\r\n    @SuppressWarnings(\"unused\")\r\n    private Random random;\r\n    public void setRandom(Random random) {\r\n        this.random = random;\r\n    }\r\n    public abstract Random createRandom();\r\n}\r\n```\r\n实际上，该实现类就是在配置文件中直接将Random类注入到其中，由于实现类实现了接口，而实现类被注入了Random类，那么实现类就可以当作接口与Random类之间的桥梁，这个桥梁是通过配置文件依赖注入建造的。\r\n\r\nRandom类如下\r\n```\r\npackage springTest;\r\n\r\npublic class Random {\r\n    private int randomNum = (int) (50 * Math.random());\r\n    public void printRandom() {\r\n        System.out.println(randomNum);\r\n    }\r\n}\r\n```\r\nSpringMain如下\r\n```\r\npackage springTest;\r\n\r\nimport org.springframework.context.ApplicationContext;\r\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\r\n\r\npublic class SpringMain {\r\n    @SuppressWarnings(\"resource\")\r\n    public static void main(String[] args) {\r\n        ApplicationContext factory = new ClassPathXmlApplicationContext(\"springTest/bean.xml\");\r\n        HelloInterface hi = (HelloInterface) factory.getBean(\"hello\");\r\n        Random random = hi.createRandom();\r\n        random.printRandom();\r\n    }\r\n\r\n}\r\n```\r\n配置文件为\r\n```\r\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\n\u003cbeans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:p=\"http://www.springframework.org/schema/p\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\"\r\n    xmlns:util=\"http://www.springframework.org/schema/util\"\r\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd\r\n        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\r\n        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.3.xsd\"\u003e\r\n\u003cbean id=\"ran\" class=\"springTest.Random\"/\u003e\r\n\u003cbean id=\"hello\" class=\"springTest.HelloAbstract\"\u003e\r\n    \u003clookup-method name=\"createRandom\" bean=\"ran\"/\u003e\r\n\u003c/bean\u003e\r\n\u003c/beans\u003e\r\n```\r\n可见，是通过lookup-method标签将id为ran的bean注入到id为hello的bean的createRandom方法中，即createRandom方法的返回值就是这个id为ran的bean(对象)。","cover":"/images/Spring-Framework.jpg","link":"spring-dependency-injection-and-control-inversion-and-its-application-in-interface-oriented-programming.html","preview":"\u003cp\u003eSpring依赖注入，指的是类之间对象实例的传递方式；将创建对象的控制权由自写代码交给Spring容器(或Spring jar包)，即控制反转。\u003c/p\u003e\n","title":"Spring依赖注入(DI)与控制反转(IoC)及在面向接口编程上的应用"},{"content":"\r\n\r\n我们的太阳处于核力和引力的微妙平衡状态，核力倾向于以亿万个氢弹的力量将星球炸开，而引力则倾向于将星球压缩至淹没，在这两种力的作用下，一颗恒星就变得成熟起来。\r\n\r\n当一团许多倍于我们太阳系的氢云被自身的引力收缩时，一颗恒星就会诞生，引力收缩气体并对其加热，引力能逐渐转换为氢原子的动能。通常情况下，气态氢内的质子的排斥电荷足以将被收缩的质子分开，但是在温度升高到绝对温度10^8-10^9开时，质子(氢原子核)的动能就会克服静电的排斥力，质子从而融合在一起并发生热核反应，从而核力取代电磁力占据主导地位，两个氢核“聚合”为氦，同时释放出巨大的能量。\r\n\r\n氢“聚合”为氦，之所以会释放出巨大的能量，是因为氢原子中的质子比氦原子中的质子重，那么就会产生质量盈余，这样盈余的质量就会根据爱因斯坦质能方程转化为能量。换句话说，释放出来的能量，是氢原子相对于氦原子的额外质量，这些质量等于释放出的能量与光速平方的比值。这样恒星就会因聚变燃烧，从而发光。\r\n\r\n但是氢原子总有聚变完的一天，那么氢原子消耗殆尽之时，恒星就会被氦原子充斥，氦原子可以看做是氢原子燃烧的废料。那么此时，核力将会变小，引力重新占上风，以至于继续压缩恒星，那么在这种收缩下恒星的温度继续升高，以至于氦原子可以燃烧并释放能量，那么燃烧后的氦原子的废料将会是锂和碳(遵循结合能曲线)。虽然废氦还可以燃烧，但是恒星的尺寸是越来越小了(因为燃料都被烧了)，但是他的温度非常高(不然废氦也无法燃烧)，从而恒星的大气层会极速膨胀。此时，恒星就不再是恒星，而是红巨星。也就意味着原先距离恒星近的星球会被如今的红巨星蒸发掉，当然这也是50亿年后的地球的命运。\r\n\r\n当废氦也消耗殆尽时，那么核燃炉将会熄灭。引力又再一次战胜核力占据压倒性优势，红巨星会在引力作用下继续坍缩，变成白矮星，也就是全部质量被压缩为地球那么大的一个小小的恒星。\r\n\r\n白矮星并不明亮，因为是燃烧废氦的结果，但是还尚未到达结合能曲线底部，也就是说白矮星还可以通过质能方程燃烧结合能曲线底部以上，氦原子以下的原子燃料继续在引力压缩恒星而产生的高温作用下燃烧。等到达结合能曲线的底部之后，恒星的内部将会被重元素(比如铁)充斥，也就无法再燃烧，恒星彻底死亡，由白矮星变为暗淡的矮星。引力再次占据主导地位，继续压缩恒星，星体的温度爆炸性上升几千倍，达到上万亿度，此时，矮星的铁核坍缩，其外层被炸毁，同时释放出星系中已知的最巨大的爆发能量，成为一个被称为超新星的爆炸恒星。一个超新星爆发时的亮度足以超过银河系上千亿颗恒星的整体亮度。\r\n\r\n超新星爆发之后，会留下一个完全死亡的星球，即中子星，只有曼哈顿大小，其密度非常大，大到所有的中子互相紧挨在一起。尽管中子星几乎看不见(恒星燃烧后的最终废料，即被重元素充斥，密度非常大，在强大的质量的作用下中子星有着强大的引力场，连光也无法逃逸，所以我们看不到，事实上，如果一个恒星是我们太阳的10-50倍，那么即使该恒星变成了中子星，那么引力还是会继续压缩它，此时没有核力抵抗引力的压缩，那么就无法阻止该恒星的最终坍缩，此时，就会变成广为人知的黑洞，黑洞仍然继承了中子星的特性，高密度、强引力场，所以光无法逃逸但是可以围绕其旋转，而进入黑洞视界内的任何物质都无法逃逸，都会被强大的引力压缩到粉碎)，但是我们仍然可以用仪器探测到。旋转的中子星会发出某些放射线，他们的作用就像外空间的宇宙灯塔，而在我们看来就会是闪烁着的星星，被称为脉冲星。\r\n\r\n当然，这并不意味着恒星的彻底死亡，这只是另一颗恒星诞生的开始，超新星爆炸后喷射出的星际物质与混合气体集聚到一个富含氢的新星中产生二代恒星，又继续上演恒星的兴衰史。\r\n\r\n事实上，把恒星的兴衰过程反方向重演，就是原子弹和氢弹，即通过结合能曲线的另一端，裂变铀元素，一次性跳到曲线的底部(铁元素)，爆发的能量相当大是因为铀在核裂变过程中的产物(铯和钾)中的质子的平均重量小于铀中的质子的平均重量，那么盈余的质量会通过质能方程被一次性转化为能量，这就是原子弹的能量来源。\r\n\r\n最后，再次感谢天才而又伟大的爱因斯坦！","cover":"/images/FixedStar.jpg","link":"the-rise-and-fall-of-stars-once-born-it's-designed-to-be-eternal.html","preview":"\u003cp\u003e我们的太阳处于核力和引力的微妙平衡状态，核力倾向于以亿万个氢弹的力量将星球炸开，而引力则倾向于将星球压缩至淹没，在这两种力的作用下，一颗恒星就变得成熟起来。\u003c/p\u003e\n","title":"恒星兴衰史:一诞生就注定永恒"},{"content":"\r\n\r\n超弦理论中，弦的大小不到质子的10^19倍(因而尚且观测不到)且是振动的，每种振动模式代表一种独特的共振或粒子(即粒子不是一个点，而是以某种模式振动的弦)。电子并不比中微子更基本，这是由于我们的显微镜还不够强大，无法观测到更深层的结构，根据弦理论，如果我们能把点粒子放大，那么我们就会看到一个小的振动弦，也就是说物质本质上是由这个振动弦产生的(由于振动而产生的一种“和声”，就像小提琴可以组合出无限多的和声，振动弦也可以构造出无限数量的物质形式，其实这样就明确解释了自然界中粒子的丰富性)，同样，物理定律可以被比作弦上所允许的和声定律，那么由无数的振动弦组成的宇宙就可以被当做一首交响曲了。","cover":"/images/Strings.jpg","link":"strings-particles-matter-and-the-universe-in-string-theory.html","preview":"\u003cp\u003e超弦理论中，弦的大小不到质子的10^19倍(因而尚且观测不到)且是振动的，每种振动模式代表一种独特的共振或粒子(即粒子不是一个点，而是以某种模式振动的弦)。\u003c/p\u003e\n","title":"弦理论中的弦、粒子、物质以及宇宙"},{"content":"\r\n\r\n在图书馆拿这本书，起初是因为它的名字吸引了我;后来在阅读了一章之后，才发现吸引我的是宿命;读完了整本书，直到现在，其实真正让我感同身受的是\"自由\"。\r\n\r\n+ 有时候我宁愿相信，人生的诸多不顺，只是因为最适合你的那条路尚未出现。\r\n+ 人最终要走上一条由自我意志推动的路。那种自我意志你可能一时看不清，却能感受到它和周围磕磕绊绊的摩擦。摩擦越剧烈，人就越痛苦。而你越痛苦，就越说明周遭处境和你的意志之间不匹配。于是你不得不改变你的处境。很多时候，是痛苦而不是欲望，推动着你在一个个处境之间跳来跳去，直到最终安定下来。在那之前，你不知道要往哪走，不知道什么时候被捉住，不知道在哪儿撞墙死掉，但你知道，不动是无论如何不成的。\r\n+ 当你停下来，你就成为了你。那时你才知道，一切纠结，一切转折，都只是自我意志在拣选它的归宿。\r\n\r\n我记得轻云爸爸那被宿命或生活给予的愧疚，于父亲，于妻子于孩子。\r\n\r\n+ 最终，爸爸在同学和红卫兵的带头人的带领下，走上了高台，当着众人的面喊了口号，念了批判书，与爷爷划清界限，并在爷爷头顶上啐了一口唾沫。\r\n+ 就是这一口唾沫，成为了爸爸心里的梗。等到他下乡时，他已经十七岁，这口唾沫开始在深夜里浮上他心头，并且变得不那么理直气壮了;十八岁时，他见到王老西挡在批斗他爹的红卫兵身前，挥舞着流氓拳一阵乱打，脸上都是血，虽然寡不敌众，但那种不要命的样子却当真把众人吓退了;二十二岁，他见到黑白电视里的审判和一系列平反……\r\n+ 后来，在漫长的岁月里，那口唾沫总是像心脏里埋着的一颗小石头，不鲜明、不显著，却总是硌得他生疼，尤其是喝了点酒、心被酒泡软了的时候，那石头的边缘几乎把心划破……\r\n\r\n轻云的父亲在倒卖外汇中被调查，谢家父子帮他重新回到厂子，但却时刻面临着调查组或公安局的调查与追捕，他不想和王老西一起做生意，但想和他一起走，南下，避风头。他也不会想到自己会请求同与厂子谈判的英国人帮他出国，更不会想到在轻云出生后将十年见不到她和她的妈妈。\r\n\r\n我记得谢一凡对员工的同情、对父亲遗命的遵从、对微月的关怀、对轻云及她妈妈的照顾。\r\n\r\n还有轻云从They are watching you到寻找自我的经历！\r\n\r\n+ 对于内心中经历过的痛苦感受，我觉得最重要的不是痛苦的来源，也不是痛苦的类型，而是自我对痛苦的意识以及之后的反应。有时候我们会误解痛苦的意义。我们走不出痛苦，不仅因为痛苦过于沉重，也因为我们沉溺其中，缺乏走出的动力。时常听到“痛苦孕育深刻”、“苦难造就伟大”之类的说辞，这对经历痛苦的人有一种诱惑的误导。可是实际上，痛苦并不是让人沉溺的东西，也不是让人用来自我标榜，或者向世界索取报偿的东西。人的命运由自己负责，世界并不负责为你的痛苦给你补偿。最终是人对痛苦的跨越，而不是痛苦本身，标示了人的价值。只有走出痛苦才能肯定它的意义。\r\n+ 对人如此，对国度也是如此。\r\n\r\n**生于一九八四，郝景芳/著**","cover":"/images/born-in-1984.jpeg","link":"born-in-1984-reading-notes.html","preview":"\u003cp\u003e有时候我宁愿相信，人生的诸多不顺，只是因为最适合你的那条路尚未出现。\u003c/p\u003e\n","title":"《生于一九八四》·阅读小记"},{"content":"\r\n\r\n一部《万历十五年》,就是一部简明扼要的明朝兴衰史。黄仁宇以独到的眼光以六个人物为代表并以万历年间为切入点 深 入阐述了一个王朝由盛极衰的原因。作者在本书中渗透的历史观足以让每一位读者对中国古代封建社会形成更为深入的理解。\r\n\r\n**皇帝以儒家伦理纲常为基维护统治秩序而又不得不与文官集团相抗衡。**\r\n\r\n封建王朝统治秩序的维护在很大程度上是依靠封建伦理道德实现的。自汉武帝罢黜百家独尊儒术确立儒家思想的正统地位伊始,直至清廷覆灭,两千年的封建社会高度契合,几无例外。上至天子,下到百姓,无不遵守。文官集团是儒家伦理的极力推动者与坚决维护者,一方面他们以此维护整个地主阶级的统治利益,另一方面他们也以此与皇帝对抗保全小集团私利。庞大的帝国并不是有一位励精图治殚精竭虑的君主就可以实现统治的,维系统治的纽带正是这各级文官与文官集团推崇的伦理纲常。英明的君主会洞悉这种 “ 潜规则 ” ,合理利用文官集团中的矛盾不仅可以牵制双方而且能够达到自己维护统治秩序稳定的目的。这万历皇帝自小就熟悉各种礼仪,受张居正的影响 ( 正面影响 ) 是具备成为好皇帝的潜质的。但权倾朝野的首辅张居正去世之后,在文官集团的检举之下其种种劣端行径暴露无疑,这位曾经被万历极度推崇依赖的首辅竟是在自己面前一套背地里一套,这给了万历莫大的打击,也为万历皇帝日后的懒政埋下了隐患。自小被礼仪伦理捆绑,为文官教导的万历就越想挣脱这种束缚,就以不上朝等行为对抗文官集团。\r\n\r\n不得不说,以伦理纲常维护统治秩序这确是一大创举,成效也是卓著的,其在诛心。程朱理学存天理灭人欲以达到维护统治秩序的目的,而由皇室与文官集团表现出来的尊卑有序君为臣纲更是为⺠间提供了一套典范,以此便能使得统治秩序的稳定。但是这也是一种愚⺠政策,在三纲五常的捆绑之下⺠智不开社会思想就难以激流勇进,发展到清朝末期其弊端显而易⻅。","cover":"/images/the-Fifteen-Years-of-Wanli.jpg","link":"thoughts-on-the-fifteen-years-of-wanli.html","preview":"\u003cp\u003e一部《万历十五年》,就是一部简明扼要的明朝兴衰史。\u003c/p\u003e\n","title":"关于《万历十五年》的一点思考"},{"content":"\r\n\r\n暑假在读客官微上看到了关于清明上河图密码的一期推送,说实话,我对悬疑推理小说兴致并不高,但我却是一个十足的历史爱好者,受这一因素的驱动,于收假后特意买来拜读。\r\n\r\n虽说我是一个典型的文科生,但是于历史而言更多的只是历史课本上学到的,以悬疑推理的方式 深 入历史还是第一次,倒也兴致高涨。故事定位在北宋末年,以《清明上河图》为原型,以四个不同领域的人物 ( 当前共出了四本 ) 为线索较为完整的串联起了北宋社会的士农工商兵等方方面面,书名也绝非沽名钓誉,确实配的上这幅画的思想精髓。\r\n\r\n一幅清明上河图就是一部北宋兴衰史,北宋帝国承平日久,图中一片欣欣向荣之景,但事实上已经危机四伏。方腊掣肘,金兵为患,辽国、西夏、高丽亦对中原王朝⻁视眈眈。清明上河图完成不久金兵便大举入侵焚城杀人,北宋繁华一夕扫尽。\r\n\r\n第一部以宗室子弟讼绝赵不尤破八子案、赵墨儿破香袋案、赵瓣儿破范楼案、宗室子弟赵不弃破变身案、以及最后搁浅的梅船案来展开布局,尤其是梅船案,目前看来这一案件是贯穿四部书的线索。本部书主要涉及到的是士子,即士农工商兵中的 “ 士 ” 。八子案中以东水八子的恩怨纠葛阐明了改革派与守成派之间的矛盾,八子案也是整部书的引子,贯穿四部书的梅船案更是与八子案密不可分。\r\n\r\n第二部是以牙绝冯赛跌宕起伏的人生经历为眉目展开的。包括金篇银篇铜篇三大部分,分别是三商案、百万案、⻜钱案。猪行、碳行、⻥行的货源被截一时间供货紧张,百万⻜钱不翼而⻜,牙绝冯赛在妻女失踪家产被抄的困境下揪出贯穿本案的引子 “ 母钱 ” 以及背后主使者广宁监的几位工人。牵扯到的社会阶层为 “ 商 ” 。而最终又回到范楼与梅船,照应了本书的主题,紧密联系了第一部,同时也给第三部埋下了伏笔。\r\n\r\n第三部以斗绝梁兴破化灰案、⻝儿案、空仓案、骷髅案为着墨点。至第三部就牵扯到了方腊,一时间读者联系前两部的各种悬疑,就会更 深 入的了解清明上河图密码之所以为密码的原因。该部书梁兴本是军中之人,因此涉及到的社会阶层是 “ 兵 ” 。\r\n\r\n第四部以作绝张用破萝卜案、焦船案、艮岳案、秘阁案为线索,一个整日疯疯癫癫的人却聪明绝顶连破四大案件,究其疯癫的原因不料确是装出来的,这里面的苦心孤诣不是三言两语能够道的清的。本部书以皇室修建艮岳为起因而揭示了日益激化的阶级矛盾,再加上⺠族矛盾使得读者很容易感觉到北宋帝国的危在旦夕。本部书主要涉及到的社会阶层为 “ 工 ” 。而社会阶层 “ 农 ” 则贯穿于每部书,毕竟农业才是封建王朝的根本。\r\n\r\n总之,就目前出的这四部书看来,作者的布局是相当庞大的,而每一部书的构思又极为精巧,每一个案件的推理与展开更是显得恰到好处而游刃有余,最为精妙的当属作者的填词。从书中看得出作者对北宋社会的⻛貌研究的很透彻,对清明上河图观察的很独到,真心希望本书能够尽快出版第五部与第六部,以飨读者!","cover":"/images/qingmingshanghetu.jpg","link":"a-domestic-masterpiece-of-conscientious-suspicious-reasoning.html","preview":"\u003cp\u003e一幅清明上河图就是一部北宋兴衰史,北宋帝国承平日久,图中一片欣欣向荣之景,但事实上已经危机四伏。\u003c/p\u003e\n","title":"《清明上河图密码》一部良心的国产悬疑推理大作"},{"content":"\r\n\r\n昨夜⻛雨洒庭轩,心微凉,夜茫茫。最是相逢仲夏晚,无料,难吟月光寒。\r\n\r\n前年漫流华表语,何所似,孤鸿影。一生难再此佳年,莫惧,蓑雨任平生。\r\n\r\n农历丙申年六月十五日作于故邑","cover":"/images/huanxisha.jpg","link":"rain-sprinkled-the-courtyard-las-night.html","preview":"\u003cp\u003e一生难再此佳年,莫惧,蓑雨任平生。\u003c/p\u003e\n","title":"浣溪沙 · 昨夜⻛雨洒庭轩"}]